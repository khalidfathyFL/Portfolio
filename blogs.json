{"status":"ok","feed":{"url":"https://medium.com/feed/@khalidfathyuar","title":"Stories by Khalid Fathy on Medium","link":"https://medium.com/@khalidfathyuar?source=rss-10666600d0ce------2","author":"","description":"Stories by Khalid Fathy on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*58rSvBHF7eOpPlM8u1Vslw.jpeg"},"items":[{"title":"Storing Custom Data in Revit Using Extensible Storage\u200a\u2014\u200aA Practical Guide","pubDate":"2025-04-19 20:17:30","link":"https://medium.com/@khalidfathyuar/storing-custom-data-in-revit-using-extensible-storage-a-practical-guide-07dcc3c2128c?source=rss-10666600d0ce------2","guid":"https://medium.com/p/07dcc3c2128c","author":"Khalid Fathy","thumbnail":"","description":"\n<h3>Storing Custom Data in Revit Using Extensible Storage\u200a\u2014\u200aA Practical Guide</h3>\n<p>When developing Revit plugins, you\u2019ll eventually need to store custom data that Revit\u2019s built-in parameters just don\u2019t support. Maybe it\u2019s spatial metadata, plugin-specific configuration, simulation results, or a timestamped action\u00a0history.</p>\n<p>Instead of relying on external databases or parameter hacks, Revit provides a native and powerful feature called <strong>Extensible Storage</strong>.</p>\n<p>It allows you to define structured, typed data (like classes), attach it to Revit elements, and retrieve it later\u200a\u2014\u200aall embedded inside the\u00a0.rvt\u00a0model.</p>\n<p>This article walks you\u00a0through:</p>\n<ul>\n<li>What Extensible Storage\u00a0is</li>\n<li>Supported field\u00a0types</li>\n<li>How to create and attach schema\u00a0data</li>\n<li>Reading that data\u00a0back</li>\n<li>Setting proper access permissions</li>\n<li>And a complete working example with best practices</li>\n</ul>\n<h3>What Is Extensible Storage?</h3>\n<p>Extensible Storage enables Revit developers to define class-like structures called <strong>schemas</strong> and attach instances of those structures, called <strong>entities</strong>, to Revit elements. Each schema defines one or more <strong>fields</strong> (similar to class properties), and entities store actual values for those\u00a0fields.</p>\n<p>You can:</p>\n<ul>\n<li>Define custom fields like XYZ, double, string,\u00a0etc.</li>\n<li>Save that data to any element in the\u00a0model</li>\n<li>Read it back later\u200a\u2014\u200aeven after reopening the\u00a0file</li>\n<li>Set access rules to control who can read or write\u00a0it</li>\n</ul>\n<p>Think of it as your plugin\u2019s personal, structured memory\u200a\u2014\u200abuilt directly into the Revit\u00a0file.</p>\n<h3>Supported Types and Their Default\u00a0Values</h3>\n<p>Extensible Storage only supports a limited set of types. Each field in your schema must be one of the following:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KDuhKSOTBeEXyATygthoGw.png\"></figure><h3>Types of Fields in Extensible Storage</h3>\n<p>In Revit\u2019s Extensible Storage API, a <strong>field</strong> is like a class property\u200a\u2014\u200ait defines what kind of data can be stored in a schema. Fields are created using SchemaBuilder and configured via a FieldBuilder.</p>\n<p>Revit supports several types of fields to suit different data structures.</p>\n<h3>Entity Fields (Nested Schemas / SubEntities)</h3>\n<p>You can create a field whose type is Autodesk.Revit.DB.ExtensibleStorage.Entity.</p>\n<p>This means a field can hold another <strong>entire schema</strong>\u200a\u2014\u200alike a class within a class. These are known as <strong>SubSchemas</strong> or <strong>SubEntities</strong>, and are useful when your data model needs to be modular or hierarchical.</p>\n<ul><li>Default value: An entity with null schema and Guid.Empty</li></ul>\n<pre>FieldBuilder field = schemaBuilder.AddSimpleField(\"SubEntityField\", typeof(Entity));<br>field.SetSubSchemaGUID(subSchemaGuid);</pre>\n<p>Use SetSubSchemaGUID() to define the expected schema inside the\u00a0field.</p>\n<h3>String Field Limitations</h3>\n<p>Revit enforces a <strong>16 MB limit</strong> on individual string values in extensible storage.</p>\n<p>So while you can use string as a field type, you must avoid storing overly large serialized blobs (like large JSON documents) inside a string\u00a0field.</p>\n<h3>Field Creation\u00a0Methods</h3>\n<p>The API provides three methods for adding fields depending on your data structure:</p>\n<h4>\u27a4 AddSimpleField(string name, Type\u00a0type)</h4>\n<p>Adds a field for a single\u00a0value.</p>\n<ul>\n<li>Allowed types: int, double, XYZ, string, bool, Guid, Entity,\u00a0etc.</li>\n<li>Returns a FieldBuilder to let you configure units, documentation, or sub-schemas.</li>\n</ul>\n<pre>FieldBuilder field = schemaBuilder.AddSimpleField(\"Length\", typeof(double));</pre>\n<h4>\u27a4 AddArrayField(string name, Type\u00a0type)</h4>\n<p>Adds a field that stores an array or list of\u00a0values.</p>\n<ul><li>Same supported types as AddSimpleField</li></ul>\n<pre>FieldBuilder arrayField = schemaBuilder.AddArrayField(\"Points\", typeof(XYZ));</pre>\n<h4>\u27a4 AddMapField(string name, Type keyType, Type valueType)</h4>\n<p>Adds a dictionary-like field that stores key-value pairs.</p>\n<ul>\n<li>Keys must be one of: int, short, byte, string, bool, ElementId, Guid</li>\n<li>Values can be any valid simple field\u00a0type</li>\n</ul>\n<pre>FieldBuilder mapField = schemaBuilder.AddMapField(\"LengthsById\", typeof(Guid), typeof(double));</pre>\n<h3>FieldBuilder and Schema Finalization</h3>\n<p>After you add a field using AddSimpleField, AddArrayField, or AddMapField, you get a FieldBuilder. Use it to configure the\u00a0field:</p>\n<ul>\n<li>SetSpec() or SetUnitType() \u2192 for numeric and vector\u00a0fields</li>\n<li>SetDocumentation() \u2192 add a description to your\u00a0field</li>\n<li>SetSubSchemaGUID() \u2192 for Entity fields (nested\u00a0schemas)</li>\n</ul>\n<pre>FieldBuilder fb = schemaBuilder.AddSimpleField(\"WireLength\", typeof(double));<br>fb.SetDocumentation(\"Length of wire in meters.\");</pre>\n<blockquote>\n<em>Once you call </em><em>schemaBuilder.Finish(), the schema is finalized and cannot be modified. After that, use </em><em>Schema.GetField(\"FieldName\") to access the\u00a0fields.</em>\n</blockquote>\n<h3>Creating and Writing Extensible Storage\u00a0Data</h3>\n<p>To write data using Extensible Storage in Revit, you follow these main\u00a0steps:</p>\n<ol>\n<li>Create a unique <strong>SchemaBuilder</strong>\n</li>\n<li>Add fields with types, documentation, and\u00a0units</li>\n<li>Set the <strong>read/write access\u00a0levels</strong>\n</li>\n<li>Finalize the\u00a0schema</li>\n<li>Create an <strong>Entity</strong> and assign field\u00a0values</li>\n<li>Attach it to a selected element in a <strong>Transaction</strong>\n</li>\n</ol>\n<p>Below is a complete implementation of a Revit external command that writes extensible storage data to an element chosen by the user. It demonstrates conditional unit support, field documentation, and access\u00a0control.</p>\n<pre>using Autodesk.Revit.Attributes;<br>using Autodesk.Revit.DB.ExtensibleStorage;<br>using Autodesk.Revit.UI;<br>using Autodesk.Revit.UI.Selection;<br>using Nice3point.Revit.Toolkit.External;<br>using OperationCanceledException = Autodesk.Revit.Exceptions.OperationCanceledException;<br><br>namespace ExtensibleStorage.Commands;<br><br>/// &lt;summary&gt;<br>///     Writes extensible storage data to a user-selected element in a Revit document.<br>///     The data includes spatial and descriptive metadata such as location, length, a note, and a timestamp.<br>/// &lt;/summary&gt;<br>[UsedImplicitly]<br>[Transaction(TransactionMode.Manual)]<br>internal class WriteExtensibleStorage : ExternalCommand<br>{<br>    public override void Execute()<br>    {<br>        // Step 1: Create schema with unique GUID<br>        var schemaBuilder = new SchemaBuilder(Guid.NewGuid());<br><br>        // Step 2: Configure schema metadata<br>        schemaBuilder.SetVendorId(\"Khalid\"); // MUST match &lt;VendorId&gt; in your .addin file<br>        schemaBuilder.SetSchemaName(\"MySchema\");<br>        schemaBuilder.SetReadAccessLevel(AccessLevel.Public);<br>        schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor);<br><br>        // Step 3: Define fields with documentation and unit handling<br>        var locationFieldBuilder = schemaBuilder.AddSimpleField(\"Location\", typeof(XYZ));<br>#if R21_OR_GREATER<br>        locationFieldBuilder.SetSpec(SpecTypeId.Length);<br>#else<br>        locationFieldBuilder.SetUnitType(UnitType.UT_Length);<br>#endif<br>        locationFieldBuilder.SetDocumentation(\"3D point representing the splice location.\");<br><br>        var lengthFieldBuilder = schemaBuilder.AddSimpleField(\"WireLength\", typeof(double));<br>#if R21_OR_GREATER<br>        lengthFieldBuilder.SetSpec(SpecTypeId.Length);<br>#else<br>        lengthFieldBuilder.SetUnitType(UnitType.UT_Length);<br>#endif<br>        lengthFieldBuilder.SetDocumentation(\"Total wire length from the splice to the endpoint.\");<br><br>        var descriptionFieldBuilder = schemaBuilder.AddSimpleField(\"Description\", typeof(string));<br>        descriptionFieldBuilder.SetDocumentation(\"Human-readable description of the wire splice.\");<br><br>        var timeFieldBuilder = schemaBuilder.AddSimpleField(\"SpliceTime\", typeof(string));<br>        timeFieldBuilder.SetDocumentation(\"The date and time of the splice in ISO-8601 format.\");<br><br>        // Step 4: Finalize the schema<br>        var schema = schemaBuilder.Finish();<br><br>        // Step 5: Create entity and populate values<br>        var entity = new Entity(schema);<br>#if R21_OR_GREATER<br>        entity.Set(schema.GetField(\"Location\"), new XYZ(1, 2, 3), UnitTypeId.Meters);<br>        entity.Set(schema.GetField(\"WireLength\"), 12.5, UnitTypeId.Meters);<br>#else<br>        entity.Set(schema.GetField(\"Location\"), new XYZ(1, 2, 3), DisplayUnitType.DUT_METERS);<br>        entity.Set(schema.GetField(\"WireLength\"), 12.5, DisplayUnitType.DUT_METERS);<br>#endif<br>        entity.Set(schema.GetField(\"Description\"), \"Main splice near junction box\");<br>        entity.Set(schema.GetField(\"SpliceTime\"), DateTime.Now.ToString(\"o\")); // ISO format<br><br>        // Step 6: Prompt for target element and apply entity<br>        try<br>        {<br>            var reference = UiDocument.Selection.PickObject(ObjectType.Element, \"Please select an element\");<br>            var element = Document.GetElement(reference);<br><br>            using var transaction = new Transaction(Document);<br>            transaction.Start(\"Write Extensible Storage\");<br>            element.SetEntity(entity);<br>            transaction.Commit();<br>        }<br>        catch (OperationCanceledException)<br>        {<br>            TaskDialog.Show(\"Canceled\", \"Operation was canceled by user.\");<br>        }<br>        catch (Exception e)<br>        {<br>            TaskDialog.Show(\"Error\", e.Message);<br>            throw;<br>        }<br>    }<br>}</pre>\n<h3>Reading Extensible Storage Data from a Revit\u00a0Element</h3>\n<p>Once you\u2019ve attached Extensible Storage data to an element, you can retrieve it anytime using the same schema. Reading the data involves:</p>\n<ol>\n<li>Identifying the correct schema (by SchemaName and VendorId)</li>\n<li>Calling element.GetEntity(schema) to retrieve the\u00a0entity</li>\n<li>Accessing individual field values using entity.Get&lt;T&gt;()</li>\n<li>Handling any missing or invalid data gracefully</li>\n</ol>\n<p>Below is a complete external command that prompts the user to select an element, fetches its Extensible Storage entity, and displays the stored information in a simple Revit TaskDialog.</p>\n<pre>using Autodesk.Revit.Attributes;<br>using Autodesk.Revit.DB.ExtensibleStorage;<br>using Autodesk.Revit.UI;<br>using Autodesk.Revit.UI.Selection;<br>using Nice3point.Revit.Toolkit.External;<br>using OperationCanceledException = Autodesk.Revit.Exceptions.OperationCanceledException;<br><br>namespace ExtensibleStorage.Commands;<br><br><br>/// &lt;summary&gt;<br>///     Command to read extensible storage data from a user-selected Revit element.<br>///     Displays stored schema data using a TaskDialog.<br>/// &lt;/summary&gt;<br>[UsedImplicitly]<br>[Transaction(TransactionMode.Manual)]<br>internal class ReadExtensibleStorage : ExternalCommand<br>{<br>    /// &lt;summary&gt;<br>    ///     Entry point for the external command.<br>    ///     Prompts the user to select an element, then reads and displays extensible storage data.<br>    /// &lt;/summary&gt;<br>    public override void Execute()<br>    {<br>        try<br>        {<br>            // Prompt user to select an element in the active document<br>            var reference = UiDocument.Selection.PickObject(ObjectType.Element, \"Please select an element\");<br>            var element = Document.GetElement(reference);<br><br>            // Retrieve the schema by name and vendor ID<br>            var schema = Schema.ListSchemas()<br>                .FirstOrDefault(s =&gt; s.SchemaName == \"MySchema\" &amp;&amp; s.VendorId == \"KHALID\"); // Replace with your actual VendorId<br><br>            if (schema == null)<br>            {<br>                TaskDialog.Show(\"Schema Not Found\", \"The schema 'MySchema' was not found.\");<br>                return;<br>            }<br><br>            // Validate selected element<br>            if (!element.IsValidObject)<br>            {<br>                TaskDialog.Show(\"Invalid Element\", \"The selected element cannot store external data.\");<br>                return;<br>            }<br><br>            // Try to get the associated entity from the element<br>            var entity = element.GetEntity(schema);<br><br>            if (!entity.IsValid())<br>            {<br>                TaskDialog.Show(\"No Data\", \"This element does not contain extensible storage data.\");<br>                return;<br>            }<br><br>            // Retrieve and format the stored values<br>#if R21_OR_GREATER<br>            var location = entity.Get&lt;XYZ&gt;(schema.GetField(\"Location\"), UnitTypeId.Meters);<br>            var length = entity.Get&lt;double&gt;(schema.GetField(\"WireLength\"), UnitTypeId.Meters);<br>#else<br>var location = entity.Get&lt;XYZ&gt;(schema.GetField(\"Location\"), DisplayUnitType.DUT_METERS);<br>var length = entity.Get&lt;double&gt;(schema.GetField(\"WireLength\"), DisplayUnitType.DUT_METERS);<br>#endif<br><br>            var description = entity.Get&lt;string&gt;(schema.GetField(\"Description\"));<br>            var timeString = entity.Get&lt;string&gt;(schema.GetField(\"SpliceTime\"));<br><br>            // Build a message to show in the TaskDialog<br>            var msg = $\"\ud83d\udccc Extensible Storage Data:\\n\\n\" +<br>                      $\"- Location: ({location.X:F2}, {location.Y:F2}, {location.Z:F2})\\n\" +<br>                      $\"- Wire Length: {length:F2} m\\n\" +<br>                      $\"- Description: {description}\\n\" +<br>                      $\"- Splice Time: {timeString}\";<br><br>            // Show the data in a Revit dialog<br>            TaskDialog.Show(\"Wire Splice Info\", msg);<br>        }<br>        catch (OperationCanceledException)<br>        {<br>            // User canceled the selection<br>            TaskDialog.Show(\"Canceled\", \"Operation canceled by user.\");<br>        }<br>        catch (Exception ex)<br>        {<br>            // Unexpected error occurred<br>            TaskDialog.Show(\"Error\", ex.Message);<br>            throw;<br>        }<br>    }<br>}</pre>\n<h3>Access Levels: Controlling Read and Write Permissions</h3>\n<p>When creating a schema, you can define <strong>who can read or write it</strong> by setting its AccessLevel:</p>\n<h3>Public</h3>\n<pre>schemaBuilder.SetReadAccessLevel(AccessLevel.Public);<br>schemaBuilder.SetWriteAccessLevel(AccessLevel.Public);</pre>\n<blockquote><em>Anyone can read and write the data. Useful for shared or open data structures.</em></blockquote>\n<h3>Vendor</h3>\n<pre>schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor);<br>schemaBuilder.SetVendorId(\"YourCompanyName\"); // must match .addin file</pre>\n<blockquote>\n<em>Only your vendor can write (read can be </em><em>Public, </em><em>Vendor, or </em><em>Application).</em>\n</blockquote>\n<p><strong>Important</strong>: When using AccessLevel.Vendor, you must match the VendorId in your\u00a0.addin\u00a0file:</p>\n<pre>&lt;VendorId&gt;YourCompanyName&lt;/VendorId&gt;</pre>\n<h3>Application</h3>\n<pre>schemaBuilder.SetWriteAccessLevel(AccessLevel.Application);<br>schemaBuilder.SetApplicationId(new Guid(\"your-plugin-guid\"));</pre>\n<blockquote><em>Only your specific add-in can access the schema. Most restrictive.</em></blockquote>\n<h3>Are There Already Schemas in Your\u00a0File?</h3>\n<p>Yes! Revit and third-party plugins often use Extensible Storage.</p>\n<p>You can inspect them\u00a0using:</p>\n<pre>var allSchemas = Schema.ListSchemas();</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wA0dnfIMfGZXbSO0QqUS1g.png\"><figcaption>showing all registered schemas in the current Revit document, including schema names, GUIDs, access levels, vendor IDs, application IDs, and documentation. These entries include both built-in Revit data and third-party plugin metadata like MySchema, PipeData, and FamilyBrowserStatus.</figcaption></figure><p>You can find the complete source code\u200a\u2014\u200aincluding both the <strong>write</strong> and <strong>read</strong> commands, with conditional compilation support for <strong>Revit 2020 through Revit 2026</strong>\u200a\u2014\u200aon my\u00a0GitHub:</p>\n<p>\ud83d\udd17 <a href=\"https://github.com/khalidfathyFL/ExtensibleStorage\">View the Extensible Storage Demo on\u00a0GitHub</a></p>\n<p>Feel free to explore, fork, or contribute. I hope this guide helps you confidently integrate structured metadata into your Revit workflows!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=07dcc3c2128c\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Storing Custom Data in Revit Using Extensible Storage\u200a\u2014\u200aA Practical Guide</h3>\n<p>When developing Revit plugins, you\u2019ll eventually need to store custom data that Revit\u2019s built-in parameters just don\u2019t support. Maybe it\u2019s spatial metadata, plugin-specific configuration, simulation results, or a timestamped action\u00a0history.</p>\n<p>Instead of relying on external databases or parameter hacks, Revit provides a native and powerful feature called <strong>Extensible Storage</strong>.</p>\n<p>It allows you to define structured, typed data (like classes), attach it to Revit elements, and retrieve it later\u200a\u2014\u200aall embedded inside the\u00a0.rvt\u00a0model.</p>\n<p>This article walks you\u00a0through:</p>\n<ul>\n<li>What Extensible Storage\u00a0is</li>\n<li>Supported field\u00a0types</li>\n<li>How to create and attach schema\u00a0data</li>\n<li>Reading that data\u00a0back</li>\n<li>Setting proper access permissions</li>\n<li>And a complete working example with best practices</li>\n</ul>\n<h3>What Is Extensible Storage?</h3>\n<p>Extensible Storage enables Revit developers to define class-like structures called <strong>schemas</strong> and attach instances of those structures, called <strong>entities</strong>, to Revit elements. Each schema defines one or more <strong>fields</strong> (similar to class properties), and entities store actual values for those\u00a0fields.</p>\n<p>You can:</p>\n<ul>\n<li>Define custom fields like XYZ, double, string,\u00a0etc.</li>\n<li>Save that data to any element in the\u00a0model</li>\n<li>Read it back later\u200a\u2014\u200aeven after reopening the\u00a0file</li>\n<li>Set access rules to control who can read or write\u00a0it</li>\n</ul>\n<p>Think of it as your plugin\u2019s personal, structured memory\u200a\u2014\u200abuilt directly into the Revit\u00a0file.</p>\n<h3>Supported Types and Their Default\u00a0Values</h3>\n<p>Extensible Storage only supports a limited set of types. Each field in your schema must be one of the following:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KDuhKSOTBeEXyATygthoGw.png\"></figure><h3>Types of Fields in Extensible Storage</h3>\n<p>In Revit\u2019s Extensible Storage API, a <strong>field</strong> is like a class property\u200a\u2014\u200ait defines what kind of data can be stored in a schema. Fields are created using SchemaBuilder and configured via a FieldBuilder.</p>\n<p>Revit supports several types of fields to suit different data structures.</p>\n<h3>Entity Fields (Nested Schemas / SubEntities)</h3>\n<p>You can create a field whose type is Autodesk.Revit.DB.ExtensibleStorage.Entity.</p>\n<p>This means a field can hold another <strong>entire schema</strong>\u200a\u2014\u200alike a class within a class. These are known as <strong>SubSchemas</strong> or <strong>SubEntities</strong>, and are useful when your data model needs to be modular or hierarchical.</p>\n<ul><li>Default value: An entity with null schema and Guid.Empty</li></ul>\n<pre>FieldBuilder field = schemaBuilder.AddSimpleField(\"SubEntityField\", typeof(Entity));<br>field.SetSubSchemaGUID(subSchemaGuid);</pre>\n<p>Use SetSubSchemaGUID() to define the expected schema inside the\u00a0field.</p>\n<h3>String Field Limitations</h3>\n<p>Revit enforces a <strong>16 MB limit</strong> on individual string values in extensible storage.</p>\n<p>So while you can use string as a field type, you must avoid storing overly large serialized blobs (like large JSON documents) inside a string\u00a0field.</p>\n<h3>Field Creation\u00a0Methods</h3>\n<p>The API provides three methods for adding fields depending on your data structure:</p>\n<h4>\u27a4 AddSimpleField(string name, Type\u00a0type)</h4>\n<p>Adds a field for a single\u00a0value.</p>\n<ul>\n<li>Allowed types: int, double, XYZ, string, bool, Guid, Entity,\u00a0etc.</li>\n<li>Returns a FieldBuilder to let you configure units, documentation, or sub-schemas.</li>\n</ul>\n<pre>FieldBuilder field = schemaBuilder.AddSimpleField(\"Length\", typeof(double));</pre>\n<h4>\u27a4 AddArrayField(string name, Type\u00a0type)</h4>\n<p>Adds a field that stores an array or list of\u00a0values.</p>\n<ul><li>Same supported types as AddSimpleField</li></ul>\n<pre>FieldBuilder arrayField = schemaBuilder.AddArrayField(\"Points\", typeof(XYZ));</pre>\n<h4>\u27a4 AddMapField(string name, Type keyType, Type valueType)</h4>\n<p>Adds a dictionary-like field that stores key-value pairs.</p>\n<ul>\n<li>Keys must be one of: int, short, byte, string, bool, ElementId, Guid</li>\n<li>Values can be any valid simple field\u00a0type</li>\n</ul>\n<pre>FieldBuilder mapField = schemaBuilder.AddMapField(\"LengthsById\", typeof(Guid), typeof(double));</pre>\n<h3>FieldBuilder and Schema Finalization</h3>\n<p>After you add a field using AddSimpleField, AddArrayField, or AddMapField, you get a FieldBuilder. Use it to configure the\u00a0field:</p>\n<ul>\n<li>SetSpec() or SetUnitType() \u2192 for numeric and vector\u00a0fields</li>\n<li>SetDocumentation() \u2192 add a description to your\u00a0field</li>\n<li>SetSubSchemaGUID() \u2192 for Entity fields (nested\u00a0schemas)</li>\n</ul>\n<pre>FieldBuilder fb = schemaBuilder.AddSimpleField(\"WireLength\", typeof(double));<br>fb.SetDocumentation(\"Length of wire in meters.\");</pre>\n<blockquote>\n<em>Once you call </em><em>schemaBuilder.Finish(), the schema is finalized and cannot be modified. After that, use </em><em>Schema.GetField(\"FieldName\") to access the\u00a0fields.</em>\n</blockquote>\n<h3>Creating and Writing Extensible Storage\u00a0Data</h3>\n<p>To write data using Extensible Storage in Revit, you follow these main\u00a0steps:</p>\n<ol>\n<li>Create a unique <strong>SchemaBuilder</strong>\n</li>\n<li>Add fields with types, documentation, and\u00a0units</li>\n<li>Set the <strong>read/write access\u00a0levels</strong>\n</li>\n<li>Finalize the\u00a0schema</li>\n<li>Create an <strong>Entity</strong> and assign field\u00a0values</li>\n<li>Attach it to a selected element in a <strong>Transaction</strong>\n</li>\n</ol>\n<p>Below is a complete implementation of a Revit external command that writes extensible storage data to an element chosen by the user. It demonstrates conditional unit support, field documentation, and access\u00a0control.</p>\n<pre>using Autodesk.Revit.Attributes;<br>using Autodesk.Revit.DB.ExtensibleStorage;<br>using Autodesk.Revit.UI;<br>using Autodesk.Revit.UI.Selection;<br>using Nice3point.Revit.Toolkit.External;<br>using OperationCanceledException = Autodesk.Revit.Exceptions.OperationCanceledException;<br><br>namespace ExtensibleStorage.Commands;<br><br>/// &lt;summary&gt;<br>///     Writes extensible storage data to a user-selected element in a Revit document.<br>///     The data includes spatial and descriptive metadata such as location, length, a note, and a timestamp.<br>/// &lt;/summary&gt;<br>[UsedImplicitly]<br>[Transaction(TransactionMode.Manual)]<br>internal class WriteExtensibleStorage : ExternalCommand<br>{<br>    public override void Execute()<br>    {<br>        // Step 1: Create schema with unique GUID<br>        var schemaBuilder = new SchemaBuilder(Guid.NewGuid());<br><br>        // Step 2: Configure schema metadata<br>        schemaBuilder.SetVendorId(\"Khalid\"); // MUST match &lt;VendorId&gt; in your .addin file<br>        schemaBuilder.SetSchemaName(\"MySchema\");<br>        schemaBuilder.SetReadAccessLevel(AccessLevel.Public);<br>        schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor);<br><br>        // Step 3: Define fields with documentation and unit handling<br>        var locationFieldBuilder = schemaBuilder.AddSimpleField(\"Location\", typeof(XYZ));<br>#if R21_OR_GREATER<br>        locationFieldBuilder.SetSpec(SpecTypeId.Length);<br>#else<br>        locationFieldBuilder.SetUnitType(UnitType.UT_Length);<br>#endif<br>        locationFieldBuilder.SetDocumentation(\"3D point representing the splice location.\");<br><br>        var lengthFieldBuilder = schemaBuilder.AddSimpleField(\"WireLength\", typeof(double));<br>#if R21_OR_GREATER<br>        lengthFieldBuilder.SetSpec(SpecTypeId.Length);<br>#else<br>        lengthFieldBuilder.SetUnitType(UnitType.UT_Length);<br>#endif<br>        lengthFieldBuilder.SetDocumentation(\"Total wire length from the splice to the endpoint.\");<br><br>        var descriptionFieldBuilder = schemaBuilder.AddSimpleField(\"Description\", typeof(string));<br>        descriptionFieldBuilder.SetDocumentation(\"Human-readable description of the wire splice.\");<br><br>        var timeFieldBuilder = schemaBuilder.AddSimpleField(\"SpliceTime\", typeof(string));<br>        timeFieldBuilder.SetDocumentation(\"The date and time of the splice in ISO-8601 format.\");<br><br>        // Step 4: Finalize the schema<br>        var schema = schemaBuilder.Finish();<br><br>        // Step 5: Create entity and populate values<br>        var entity = new Entity(schema);<br>#if R21_OR_GREATER<br>        entity.Set(schema.GetField(\"Location\"), new XYZ(1, 2, 3), UnitTypeId.Meters);<br>        entity.Set(schema.GetField(\"WireLength\"), 12.5, UnitTypeId.Meters);<br>#else<br>        entity.Set(schema.GetField(\"Location\"), new XYZ(1, 2, 3), DisplayUnitType.DUT_METERS);<br>        entity.Set(schema.GetField(\"WireLength\"), 12.5, DisplayUnitType.DUT_METERS);<br>#endif<br>        entity.Set(schema.GetField(\"Description\"), \"Main splice near junction box\");<br>        entity.Set(schema.GetField(\"SpliceTime\"), DateTime.Now.ToString(\"o\")); // ISO format<br><br>        // Step 6: Prompt for target element and apply entity<br>        try<br>        {<br>            var reference = UiDocument.Selection.PickObject(ObjectType.Element, \"Please select an element\");<br>            var element = Document.GetElement(reference);<br><br>            using var transaction = new Transaction(Document);<br>            transaction.Start(\"Write Extensible Storage\");<br>            element.SetEntity(entity);<br>            transaction.Commit();<br>        }<br>        catch (OperationCanceledException)<br>        {<br>            TaskDialog.Show(\"Canceled\", \"Operation was canceled by user.\");<br>        }<br>        catch (Exception e)<br>        {<br>            TaskDialog.Show(\"Error\", e.Message);<br>            throw;<br>        }<br>    }<br>}</pre>\n<h3>Reading Extensible Storage Data from a Revit\u00a0Element</h3>\n<p>Once you\u2019ve attached Extensible Storage data to an element, you can retrieve it anytime using the same schema. Reading the data involves:</p>\n<ol>\n<li>Identifying the correct schema (by SchemaName and VendorId)</li>\n<li>Calling element.GetEntity(schema) to retrieve the\u00a0entity</li>\n<li>Accessing individual field values using entity.Get&lt;T&gt;()</li>\n<li>Handling any missing or invalid data gracefully</li>\n</ol>\n<p>Below is a complete external command that prompts the user to select an element, fetches its Extensible Storage entity, and displays the stored information in a simple Revit TaskDialog.</p>\n<pre>using Autodesk.Revit.Attributes;<br>using Autodesk.Revit.DB.ExtensibleStorage;<br>using Autodesk.Revit.UI;<br>using Autodesk.Revit.UI.Selection;<br>using Nice3point.Revit.Toolkit.External;<br>using OperationCanceledException = Autodesk.Revit.Exceptions.OperationCanceledException;<br><br>namespace ExtensibleStorage.Commands;<br><br><br>/// &lt;summary&gt;<br>///     Command to read extensible storage data from a user-selected Revit element.<br>///     Displays stored schema data using a TaskDialog.<br>/// &lt;/summary&gt;<br>[UsedImplicitly]<br>[Transaction(TransactionMode.Manual)]<br>internal class ReadExtensibleStorage : ExternalCommand<br>{<br>    /// &lt;summary&gt;<br>    ///     Entry point for the external command.<br>    ///     Prompts the user to select an element, then reads and displays extensible storage data.<br>    /// &lt;/summary&gt;<br>    public override void Execute()<br>    {<br>        try<br>        {<br>            // Prompt user to select an element in the active document<br>            var reference = UiDocument.Selection.PickObject(ObjectType.Element, \"Please select an element\");<br>            var element = Document.GetElement(reference);<br><br>            // Retrieve the schema by name and vendor ID<br>            var schema = Schema.ListSchemas()<br>                .FirstOrDefault(s =&gt; s.SchemaName == \"MySchema\" &amp;&amp; s.VendorId == \"KHALID\"); // Replace with your actual VendorId<br><br>            if (schema == null)<br>            {<br>                TaskDialog.Show(\"Schema Not Found\", \"The schema 'MySchema' was not found.\");<br>                return;<br>            }<br><br>            // Validate selected element<br>            if (!element.IsValidObject)<br>            {<br>                TaskDialog.Show(\"Invalid Element\", \"The selected element cannot store external data.\");<br>                return;<br>            }<br><br>            // Try to get the associated entity from the element<br>            var entity = element.GetEntity(schema);<br><br>            if (!entity.IsValid())<br>            {<br>                TaskDialog.Show(\"No Data\", \"This element does not contain extensible storage data.\");<br>                return;<br>            }<br><br>            // Retrieve and format the stored values<br>#if R21_OR_GREATER<br>            var location = entity.Get&lt;XYZ&gt;(schema.GetField(\"Location\"), UnitTypeId.Meters);<br>            var length = entity.Get&lt;double&gt;(schema.GetField(\"WireLength\"), UnitTypeId.Meters);<br>#else<br>var location = entity.Get&lt;XYZ&gt;(schema.GetField(\"Location\"), DisplayUnitType.DUT_METERS);<br>var length = entity.Get&lt;double&gt;(schema.GetField(\"WireLength\"), DisplayUnitType.DUT_METERS);<br>#endif<br><br>            var description = entity.Get&lt;string&gt;(schema.GetField(\"Description\"));<br>            var timeString = entity.Get&lt;string&gt;(schema.GetField(\"SpliceTime\"));<br><br>            // Build a message to show in the TaskDialog<br>            var msg = $\"\ud83d\udccc Extensible Storage Data:\\n\\n\" +<br>                      $\"- Location: ({location.X:F2}, {location.Y:F2}, {location.Z:F2})\\n\" +<br>                      $\"- Wire Length: {length:F2} m\\n\" +<br>                      $\"- Description: {description}\\n\" +<br>                      $\"- Splice Time: {timeString}\";<br><br>            // Show the data in a Revit dialog<br>            TaskDialog.Show(\"Wire Splice Info\", msg);<br>        }<br>        catch (OperationCanceledException)<br>        {<br>            // User canceled the selection<br>            TaskDialog.Show(\"Canceled\", \"Operation canceled by user.\");<br>        }<br>        catch (Exception ex)<br>        {<br>            // Unexpected error occurred<br>            TaskDialog.Show(\"Error\", ex.Message);<br>            throw;<br>        }<br>    }<br>}</pre>\n<h3>Access Levels: Controlling Read and Write Permissions</h3>\n<p>When creating a schema, you can define <strong>who can read or write it</strong> by setting its AccessLevel:</p>\n<h3>Public</h3>\n<pre>schemaBuilder.SetReadAccessLevel(AccessLevel.Public);<br>schemaBuilder.SetWriteAccessLevel(AccessLevel.Public);</pre>\n<blockquote><em>Anyone can read and write the data. Useful for shared or open data structures.</em></blockquote>\n<h3>Vendor</h3>\n<pre>schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor);<br>schemaBuilder.SetVendorId(\"YourCompanyName\"); // must match .addin file</pre>\n<blockquote>\n<em>Only your vendor can write (read can be </em><em>Public, </em><em>Vendor, or </em><em>Application).</em>\n</blockquote>\n<p><strong>Important</strong>: When using AccessLevel.Vendor, you must match the VendorId in your\u00a0.addin\u00a0file:</p>\n<pre>&lt;VendorId&gt;YourCompanyName&lt;/VendorId&gt;</pre>\n<h3>Application</h3>\n<pre>schemaBuilder.SetWriteAccessLevel(AccessLevel.Application);<br>schemaBuilder.SetApplicationId(new Guid(\"your-plugin-guid\"));</pre>\n<blockquote><em>Only your specific add-in can access the schema. Most restrictive.</em></blockquote>\n<h3>Are There Already Schemas in Your\u00a0File?</h3>\n<p>Yes! Revit and third-party plugins often use Extensible Storage.</p>\n<p>You can inspect them\u00a0using:</p>\n<pre>var allSchemas = Schema.ListSchemas();</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wA0dnfIMfGZXbSO0QqUS1g.png\"><figcaption>showing all registered schemas in the current Revit document, including schema names, GUIDs, access levels, vendor IDs, application IDs, and documentation. These entries include both built-in Revit data and third-party plugin metadata like MySchema, PipeData, and FamilyBrowserStatus.</figcaption></figure><p>You can find the complete source code\u200a\u2014\u200aincluding both the <strong>write</strong> and <strong>read</strong> commands, with conditional compilation support for <strong>Revit 2020 through Revit 2026</strong>\u200a\u2014\u200aon my\u00a0GitHub:</p>\n<p>\ud83d\udd17 <a href=\"https://github.com/khalidfathyFL/ExtensibleStorage\">View the Extensible Storage Demo on\u00a0GitHub</a></p>\n<p>Feel free to explore, fork, or contribute. I hope this guide helps you confidently integrate structured metadata into your Revit workflows!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=07dcc3c2128c\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["revit","autodesk","revitapi","development"]}]}