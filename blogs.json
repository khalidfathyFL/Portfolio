{"status":"ok","feed":{"url":"https://medium.com/feed/@khalidfathyuar","title":"Stories by Khalid Fathy on Medium","link":"https://medium.com/@khalidfathyuar?source=rss-10666600d0ce------2","author":"","description":"Stories by Khalid Fathy on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*58rSvBHF7eOpPlM8u1Vslw.jpeg"},"items":[{"title":"Prevent Multiple Windows in a Revit Plugin\u200a\u2014\u200aManual Singleton vs. Window Controller","pubDate":"2025-06-12 17:51:25","link":"https://medium.com/@khalidfathyuar/prevent-multiple-windows-in-a-revit-plugin-manual-singleton-vs-window-controller-b84370851097?source=rss-10666600d0ce------2","guid":"https://medium.com/p/b84370851097","author":"Khalid Fathy","thumbnail":"","description":"\n<h3>\ud83e\udde9 Prevent Multiple Windows in a Revit Plugin\u200a\u2014\u200aManual Singleton vs. Window Controller</h3>\n<p>In Revit plugin development, it\u2019s common to build WPF UI tools to assist with modeling, tagging, or data management. But one frustrating UX problem arises\u00a0often:</p>\n<blockquote><em>\ud83d\udd01 The same window opens multiple\u00a0times.</em></blockquote>\n<p>This typically happens when there\u2019s no mechanism in place to control <strong>how</strong> and <strong>when</strong> your WPF windows are created and\u00a0shown.</p>\n<p>To solve this properly, you have two reliable patterns:</p>\n<ul>\n<li>\u2705 <strong>Manual Singleton</strong> (inside the window\u00a0class)</li>\n<li>\u2705 <strong>WindowController</strong> (recommended for scalable architecture)</li>\n</ul>\n<p>But before we dive into the implementations, let\u2019s understand <strong>why this happens specifically in Revit</strong>\u200a\u2014\u200aand <strong>why Dependency Injection (DI)</strong> won\u2019t help you\u00a0here.</p>\n<h3>\ud83d\udd0d Why You Can\u2019t Use Dependency Injection for Windows in\u00a0Revit</h3>\n<p>In standard\u00a0.NET applications, using DI to manage window lifetimes is\u00a0normal:</p>\n<pre>services.AddSingleton&lt;MyWindow&gt;(); // \u274c Looks valid, but unsafe in Revit</pre>\n<p>However, <strong>Revit is not a typical application</strong>\u200a\u2014\u200ait <strong>controls the plugin lifecycle</strong>, and each time your external command is run, Revit\u00a0may:</p>\n<ul>\n<li>Reload your add-in\u00a0assembly</li>\n<li>Recreate view models and\u00a0services</li>\n<li>Discard or reset your DI container</li>\n</ul>\n<p>This means that even if you registered a window as a singleton, <strong>Revit might give you a reference to an already disposed\u00a0window</strong>.</p>\n<p>If the user closed the window after the first use, trying to show it again later will cause\u00a0this:</p>\n<pre>System.InvalidOperationException: Cannot show a disposed object.</pre>\n<p>And that could even <strong>crash\u00a0Revit</strong>.</p>\n<h3>\u2705 Conclusion: Don\u2019t use DI to manage WPF window lifetimes in\u00a0Revit</h3>\n<p>Instead, you need to <strong>manage the window lifecycle manually</strong>\u200a\u2014\u200aeither\u00a0by:</p>\n<ul>\n<li>Implementing a Singleton pattern inside the window,\u00a0or</li>\n<li>Using a reusable controller to track open windows and focus/reopen as\u00a0needed</li>\n</ul>\n<p>Let\u2019s walk through\u00a0both.</p>\n<h3>\u2705 Approach 1\u200a\u2014\u200aManual Singleton Inside the\u00a0Window</h3>\n<p>The most direct approach is to place a static instance inside the window class and handle its lifecycle manually.</p>\n<h3>\ud83d\udd27 Implementation</h3>\n<pre>    public sealed partial class RevitAddIn3View<br>    {<br>        private static RevitAddIn3View? _instance;<br><br>        public static RevitAddIn3View GetInstance()<br>        {<br>            if (_instance == null || !_instance.IsLoaded)<br>            {<br>                var viewModel = new RevitAddIn3ViewModel();<br>                _instance = new RevitAddIn3View(viewModel);<br>                _instance.Closed += (_, _) =&gt; _instance = null;<br>            }<br>            else<br>            {<br>                if (_instance.WindowState == System.Windows.WindowState.Minimized)<br>                    _instance.WindowState = System.Windows.WindowState.Normal;<br><br>                if (_instance.Visibility != System.Windows.Visibility.Visible)<br>                    _instance.Show();<br><br>                _instance.Focus();<br>            }<br><br>            return _instance;<br>        }<br><br>        private RevitAddIn3View(RevitAddIn3ViewModel viewModel)<br>        {<br>            DataContext = viewModel;<br>            InitializeComponent();<br>        }<br>    }</pre>\n<h3>\ud83e\uddea Usage</h3>\n<pre>RevitAddIn3View.GetInstance().Show();</pre>\n<h3>\u2705 Pros</h3>\n<ul>\n<li>Easy to implement</li>\n<li>No external dependencies</li>\n<li>Ensures one active instance per window\u00a0type</li>\n</ul>\n<h3>\u274c Cons</h3>\n<ul>\n<li>Logic is tightly coupled with the\u00a0window</li>\n<li>Not reusable across different window\u00a0types</li>\n<li>Difficult to scale across large\u00a0toolsets</li>\n</ul>\n<h3>\u2705 Approach 2\u200a\u2014\u200aWindowController (Recommended)</h3>\n<p>For more modular or scalable plugins, it\u2019s better to <strong>decouple window tracking logic</strong> from the window itself. This is where the WindowController pattern comes\u00a0in.</p>\n<h3>\ud83d\udce6 Implementation</h3>\n<pre>namespace MBFWpfToolkit.Helpers<br>{<br>    public static class WindowController<br>    {<br>        private static readonly List&lt;Window&gt; Windows = new();<br>        public static bool Focus&lt;T&gt;() where T : Window<br>        {<br>            foreach (var window in Windows)<br>                if (window is T target)<br>                {<br>                    if (target.WindowState == WindowState.Minimized)<br>                        target.WindowState = WindowState.Normal;<br>                    if (target.Visibility != Visibility.Visible)<br>                        target.Show();<br>                    target.Focus();<br>                    return true;<br>                }<br>            return false;<br>        }<br>        public static void Show(Window window)<br>        {<br>            RegisterWindow(window);<br>            window.Show();<br>        }<br>        public static void Show(Window window, IntPtr handle)<br>        {<br>            RegisterWindow(window);<br>            new WindowInteropHelper(window) { Owner = handle }.Show();<br>        }<br>        public static bool? ShowDialog(Window window)<br>        {<br>            RegisterWindow(window);<br>            return window.ShowDialog();<br>        }<br>        public static bool? ShowDialog(Window window, IntPtr handle)<br>        {<br>            RegisterWindow(window);<br>            new WindowInteropHelper(window) { Owner = handle };<br>            return window.ShowDialog();<br>        }<br>        public static void Close&lt;T&gt;() where T : Window<br>        {<br>            for (int i = Windows.Count - 1; i &gt;= 0; i--)<br>                if (Windows[i] is T)<br>                    Windows[i].Close();<br>        }<br>        private static void RegisterWindow(Window window)<br>        {<br>            Windows.Add(window);<br>            window.Closed += (_, _) =&gt; Windows.Remove(window);<br>        }<br>    }<br>}</pre>\n<h3>\ud83e\uddea Usage</h3>\n<pre>if (!WindowController.Focus&lt;RevitAddIn3View&gt;())<br>{<br>    var window = new RevitAddIn3View(new RevitAddIn3ViewModel());<br>    WindowController.Show(window);<br>}</pre>\n<h3>\u2705 Pros</h3>\n<ul>\n<li>Clean, decoupled, reusable</li>\n<li>Supports multiple\u00a0windows</li>\n<li>Easy to test and\u00a0maintain</li>\n<li>Safer in long-running or large\u00a0plugins</li>\n</ul>\n<h3>\u274c Cons</h3>\n<ul>\n<li>Slightly more\u00a0setup</li>\n<li>Requires passing view models\u00a0manually</li>\n</ul>\n<h3>\u2696\ufe0f Singleton vs. WindowController\u200a\u2014\u200aComparison</h3>\n<h3>\ud83e\udde9 Manual Singleton\u200a\u2014\u200aSummary</h3>\n<ul>\n<li>\u2705 Prevents multiple instances</li>\n<li>\u2705 Brings window to\u00a0front</li>\n<li>\u2705 Cleans up on\u00a0close</li>\n<li>\u274c Not decoupled from window\u00a0logic</li>\n<li>\u274c Doesn\u2019t support multiple window\u00a0types</li>\n<li>\u274c Not ideal for scalable or modular\u00a0plugins</li>\n</ul>\n<h3>\ud83e\udde9 WindowController (Recommended)\u200a\u2014\u200aSummary</h3>\n<ul>\n<li>\u2705 Prevents multiple instances</li>\n<li>\u2705 Brings window to\u00a0front</li>\n<li>\u2705 Cleans up on\u00a0close</li>\n<li>\u2705 Fully decoupled from window\u00a0logic</li>\n<li>\u2705 Supports multiple window\u00a0types</li>\n<li>\u2705 Ideal for scalable, maintainable plugin architecture</li>\n</ul>\n<h3>\ud83e\udde0 Final\u00a0Thoughts</h3>\n<p>When developing Revit plugins, avoid using Dependency Injection to manage window lifecycles\u200a\u2014\u200ait\u2019s not safe. Revit\u2019s lifecycle management makes it unreliable, and reused DI-managed windows may be <strong>disposed or invalid</strong>, leading to exceptions or\u00a0crashes.</p>\n<p>Instead, you have two solid\u00a0choices:</p>\n<ul>\n<li>\u2705 Use a <strong>manual singleton</strong> for quick, isolated\u00a0tools</li>\n<li>\u2705 Use a <strong>WindowController</strong> if you want clean architecture, flexibility, and scalability</li>\n</ul>\n<h3>\ud83d\udcac What\u2019s Your Approach?</h3>\n<p>Have you run into issues with duplicate windows in your Revit plugin?<br> Do you use a different lifecycle strategy?</p>\n<p>Let\u2019s connect on <a href=\"https://www.linkedin.com/in/khalidfathyua1/\">LinkedIn </a>and share insights! Feel free to drop your thoughts in the comments.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b84370851097\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>\ud83e\udde9 Prevent Multiple Windows in a Revit Plugin\u200a\u2014\u200aManual Singleton vs. Window Controller</h3>\n<p>In Revit plugin development, it\u2019s common to build WPF UI tools to assist with modeling, tagging, or data management. But one frustrating UX problem arises\u00a0often:</p>\n<blockquote><em>\ud83d\udd01 The same window opens multiple\u00a0times.</em></blockquote>\n<p>This typically happens when there\u2019s no mechanism in place to control <strong>how</strong> and <strong>when</strong> your WPF windows are created and\u00a0shown.</p>\n<p>To solve this properly, you have two reliable patterns:</p>\n<ul>\n<li>\u2705 <strong>Manual Singleton</strong> (inside the window\u00a0class)</li>\n<li>\u2705 <strong>WindowController</strong> (recommended for scalable architecture)</li>\n</ul>\n<p>But before we dive into the implementations, let\u2019s understand <strong>why this happens specifically in Revit</strong>\u200a\u2014\u200aand <strong>why Dependency Injection (DI)</strong> won\u2019t help you\u00a0here.</p>\n<h3>\ud83d\udd0d Why You Can\u2019t Use Dependency Injection for Windows in\u00a0Revit</h3>\n<p>In standard\u00a0.NET applications, using DI to manage window lifetimes is\u00a0normal:</p>\n<pre>services.AddSingleton&lt;MyWindow&gt;(); // \u274c Looks valid, but unsafe in Revit</pre>\n<p>However, <strong>Revit is not a typical application</strong>\u200a\u2014\u200ait <strong>controls the plugin lifecycle</strong>, and each time your external command is run, Revit\u00a0may:</p>\n<ul>\n<li>Reload your add-in\u00a0assembly</li>\n<li>Recreate view models and\u00a0services</li>\n<li>Discard or reset your DI container</li>\n</ul>\n<p>This means that even if you registered a window as a singleton, <strong>Revit might give you a reference to an already disposed\u00a0window</strong>.</p>\n<p>If the user closed the window after the first use, trying to show it again later will cause\u00a0this:</p>\n<pre>System.InvalidOperationException: Cannot show a disposed object.</pre>\n<p>And that could even <strong>crash\u00a0Revit</strong>.</p>\n<h3>\u2705 Conclusion: Don\u2019t use DI to manage WPF window lifetimes in\u00a0Revit</h3>\n<p>Instead, you need to <strong>manage the window lifecycle manually</strong>\u200a\u2014\u200aeither\u00a0by:</p>\n<ul>\n<li>Implementing a Singleton pattern inside the window,\u00a0or</li>\n<li>Using a reusable controller to track open windows and focus/reopen as\u00a0needed</li>\n</ul>\n<p>Let\u2019s walk through\u00a0both.</p>\n<h3>\u2705 Approach 1\u200a\u2014\u200aManual Singleton Inside the\u00a0Window</h3>\n<p>The most direct approach is to place a static instance inside the window class and handle its lifecycle manually.</p>\n<h3>\ud83d\udd27 Implementation</h3>\n<pre>    public sealed partial class RevitAddIn3View<br>    {<br>        private static RevitAddIn3View? _instance;<br><br>        public static RevitAddIn3View GetInstance()<br>        {<br>            if (_instance == null || !_instance.IsLoaded)<br>            {<br>                var viewModel = new RevitAddIn3ViewModel();<br>                _instance = new RevitAddIn3View(viewModel);<br>                _instance.Closed += (_, _) =&gt; _instance = null;<br>            }<br>            else<br>            {<br>                if (_instance.WindowState == System.Windows.WindowState.Minimized)<br>                    _instance.WindowState = System.Windows.WindowState.Normal;<br><br>                if (_instance.Visibility != System.Windows.Visibility.Visible)<br>                    _instance.Show();<br><br>                _instance.Focus();<br>            }<br><br>            return _instance;<br>        }<br><br>        private RevitAddIn3View(RevitAddIn3ViewModel viewModel)<br>        {<br>            DataContext = viewModel;<br>            InitializeComponent();<br>        }<br>    }</pre>\n<h3>\ud83e\uddea Usage</h3>\n<pre>RevitAddIn3View.GetInstance().Show();</pre>\n<h3>\u2705 Pros</h3>\n<ul>\n<li>Easy to implement</li>\n<li>No external dependencies</li>\n<li>Ensures one active instance per window\u00a0type</li>\n</ul>\n<h3>\u274c Cons</h3>\n<ul>\n<li>Logic is tightly coupled with the\u00a0window</li>\n<li>Not reusable across different window\u00a0types</li>\n<li>Difficult to scale across large\u00a0toolsets</li>\n</ul>\n<h3>\u2705 Approach 2\u200a\u2014\u200aWindowController (Recommended)</h3>\n<p>For more modular or scalable plugins, it\u2019s better to <strong>decouple window tracking logic</strong> from the window itself. This is where the WindowController pattern comes\u00a0in.</p>\n<h3>\ud83d\udce6 Implementation</h3>\n<pre>namespace MBFWpfToolkit.Helpers<br>{<br>    public static class WindowController<br>    {<br>        private static readonly List&lt;Window&gt; Windows = new();<br>        public static bool Focus&lt;T&gt;() where T : Window<br>        {<br>            foreach (var window in Windows)<br>                if (window is T target)<br>                {<br>                    if (target.WindowState == WindowState.Minimized)<br>                        target.WindowState = WindowState.Normal;<br>                    if (target.Visibility != Visibility.Visible)<br>                        target.Show();<br>                    target.Focus();<br>                    return true;<br>                }<br>            return false;<br>        }<br>        public static void Show(Window window)<br>        {<br>            RegisterWindow(window);<br>            window.Show();<br>        }<br>        public static void Show(Window window, IntPtr handle)<br>        {<br>            RegisterWindow(window);<br>            new WindowInteropHelper(window) { Owner = handle }.Show();<br>        }<br>        public static bool? ShowDialog(Window window)<br>        {<br>            RegisterWindow(window);<br>            return window.ShowDialog();<br>        }<br>        public static bool? ShowDialog(Window window, IntPtr handle)<br>        {<br>            RegisterWindow(window);<br>            new WindowInteropHelper(window) { Owner = handle };<br>            return window.ShowDialog();<br>        }<br>        public static void Close&lt;T&gt;() where T : Window<br>        {<br>            for (int i = Windows.Count - 1; i &gt;= 0; i--)<br>                if (Windows[i] is T)<br>                    Windows[i].Close();<br>        }<br>        private static void RegisterWindow(Window window)<br>        {<br>            Windows.Add(window);<br>            window.Closed += (_, _) =&gt; Windows.Remove(window);<br>        }<br>    }<br>}</pre>\n<h3>\ud83e\uddea Usage</h3>\n<pre>if (!WindowController.Focus&lt;RevitAddIn3View&gt;())<br>{<br>    var window = new RevitAddIn3View(new RevitAddIn3ViewModel());<br>    WindowController.Show(window);<br>}</pre>\n<h3>\u2705 Pros</h3>\n<ul>\n<li>Clean, decoupled, reusable</li>\n<li>Supports multiple\u00a0windows</li>\n<li>Easy to test and\u00a0maintain</li>\n<li>Safer in long-running or large\u00a0plugins</li>\n</ul>\n<h3>\u274c Cons</h3>\n<ul>\n<li>Slightly more\u00a0setup</li>\n<li>Requires passing view models\u00a0manually</li>\n</ul>\n<h3>\u2696\ufe0f Singleton vs. WindowController\u200a\u2014\u200aComparison</h3>\n<h3>\ud83e\udde9 Manual Singleton\u200a\u2014\u200aSummary</h3>\n<ul>\n<li>\u2705 Prevents multiple instances</li>\n<li>\u2705 Brings window to\u00a0front</li>\n<li>\u2705 Cleans up on\u00a0close</li>\n<li>\u274c Not decoupled from window\u00a0logic</li>\n<li>\u274c Doesn\u2019t support multiple window\u00a0types</li>\n<li>\u274c Not ideal for scalable or modular\u00a0plugins</li>\n</ul>\n<h3>\ud83e\udde9 WindowController (Recommended)\u200a\u2014\u200aSummary</h3>\n<ul>\n<li>\u2705 Prevents multiple instances</li>\n<li>\u2705 Brings window to\u00a0front</li>\n<li>\u2705 Cleans up on\u00a0close</li>\n<li>\u2705 Fully decoupled from window\u00a0logic</li>\n<li>\u2705 Supports multiple window\u00a0types</li>\n<li>\u2705 Ideal for scalable, maintainable plugin architecture</li>\n</ul>\n<h3>\ud83e\udde0 Final\u00a0Thoughts</h3>\n<p>When developing Revit plugins, avoid using Dependency Injection to manage window lifecycles\u200a\u2014\u200ait\u2019s not safe. Revit\u2019s lifecycle management makes it unreliable, and reused DI-managed windows may be <strong>disposed or invalid</strong>, leading to exceptions or\u00a0crashes.</p>\n<p>Instead, you have two solid\u00a0choices:</p>\n<ul>\n<li>\u2705 Use a <strong>manual singleton</strong> for quick, isolated\u00a0tools</li>\n<li>\u2705 Use a <strong>WindowController</strong> if you want clean architecture, flexibility, and scalability</li>\n</ul>\n<h3>\ud83d\udcac What\u2019s Your Approach?</h3>\n<p>Have you run into issues with duplicate windows in your Revit plugin?<br> Do you use a different lifecycle strategy?</p>\n<p>Let\u2019s connect on <a href=\"https://www.linkedin.com/in/khalidfathyua1/\">LinkedIn </a>and share insights! Feel free to drop your thoughts in the comments.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b84370851097\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["wpf","autodesk","revitapi"]},{"title":"Aspect-Oriented Programming (AOP) in\u00a0.NET with MethodBoundaryAspect.Fody","pubDate":"2025-04-26 11:11:24","link":"https://medium.com/@khalidfathyuar/aspect-oriented-programming-aop-in-net-with-methodboundaryaspect-fody-c09d36806d4d?source=rss-10666600d0ce------2","guid":"https://medium.com/p/c09d36806d4d","author":"Khalid Fathy","thumbnail":"","description":"\n<h3>Aspect-Oriented Programming (AOP) in\u00a0.NET with MethodBoundaryAspect.Fody</h3>\n<p><strong>Simplifying Logging, Transaction Handling, Performance Monitoring, and\u00a0More</strong></p>\n<h3>\ud83d\ude80 Why Should You Care About\u00a0AOP?</h3>\n<p>In modern software development, we often face challenges where certain logic cuts across multiple parts of the application\u200a\u2014\u200athings\u00a0like:</p>\n<ul>\n<li>Logging</li>\n<li>Exception handling</li>\n<li>Caching</li>\n<li>Transaction management</li>\n<li>Performance monitoring</li>\n<li>Authorization and security\u00a0checks</li>\n</ul>\n<p>These are known as <strong>cross-cutting concerns</strong>. In traditional Object-Oriented Programming (OOP), addressing these concerns can lead\u00a0to:</p>\n<ul>\n<li>Scattered and duplicated code</li>\n<li>Violation of the Single Responsibility Principle (SRP)</li>\n<li>Difficulties in maintenance, testing, and\u00a0scaling</li>\n</ul>\n<p><strong>Aspect-Oriented Programming (AOP)</strong> provides a clean, elegant solution. It helps you separate these concerns from your core business logic by injecting them automatically at compile time or runtime\u200a\u2014\u200akeeping your methods clean and focused on their main responsibilities.</p>\n<h3>\ud83d\udca1 What is MethodBoundaryAspect.Fody?</h3>\n<p><strong>MethodBoundaryAspect.Fody</strong> is a Fody weaver that allows you to inject custom logic\u00a0at:</p>\n<ul>\n<li>Method <strong>entry</strong>\n</li>\n<li>Method <strong>exit</strong>\n</li>\n<li>On <strong>exceptions</strong>\n</li>\n</ul>\n<p>This is done simply by decorating your methods or classes with attributes\u200a\u2014\u200ano need to manually sprinkle repetitive code everywhere.</p>\n<h3>\ud83d\udee0\ufe0f Key Features:</h3>\n<ul>\n<li>Hook into method lifecycle: entry, exit, and exception</li>\n<li>Access rich method metadata (method info, arguments, instance, exception details)</li>\n<li>Share context between entry and exit via MethodExecutionArgs.MethodExecutionTag</li>\n<li>Apply globally, per class, or per\u00a0method</li>\n<li>Filter target methods using Regex (NamespaceFilter, TypeNameFilter, MethodNameFilter)</li>\n<li>Modify input arguments and override return\u00a0values</li>\n</ul>\n<h3>\u26a1 Example Use Cases and Implementations</h3>\n<h3>\ud83c\udfe6 Transaction Handling\u00a0Aspect</h3>\n<p>Ensure that every method wrapped in a transaction handles completion and rollback properly.</p>\n<p><strong>Implementation:</strong></p>\n<pre>public sealed class TransactionScopeAttribute : OnMethodBoundaryAspect<br>{<br>    public override void OnEntry(MethodExecutionArgs args)<br>    {<br>        args.MethodExecutionTag = new TransactionScope();<br>    } <br><br>    public override void OnExit(MethodExecutionArgs args)<br>    {<br>        var transactionScope = (TransactionScope)args.MethodExecutionTag;<br>        transactionScope.Complete();<br>        transactionScope.Dispose();<br>    }<br><br>    public override void OnException(MethodExecutionArgs args)<br>    {<br>        var transactionScope = (TransactionScope)args.MethodExecutionTag;<br>        transactionScope.Dispose();<br>    }<br>}</pre>\n<p><strong>Usage Example:</strong></p>\n<pre>public class UserService<br>{<br>    [TransactionScope]<br>    public void CreateUser()<br>    {<br>        Console.WriteLine(\"Creating user...\");<br>        // Database logic here<br>    }<br>}</pre>\n<h3>\ud83d\udcdd Logging Aspect with\u00a0Serilog</h3>\n<p>Log method entry, exit, execution time, and handle exceptions gracefully.</p>\n<p><strong>Implementation:</strong></p>\n<pre>public sealed class LogAspect : OnMethodBoundaryAspect<br>{<br>    public override void OnEntry(MethodExecutionArgs args)<br>    {<br>        var methodName = args.Method.Name;<br>        var className = args.Method.DeclaringType.FullName;<br>        args.MethodExecutionTag = Stopwatch.StartNew();<br>        Log.Information(\"Entering {ClassName}.{MethodName} with arguments: {@Arguments}\", <br>            className, methodName, args.Arguments);<br>    }<br><br>    public override void OnExit(MethodExecutionArgs args)<br>    {<br>            var methodName = args.Method.Name;<br>            var className = args.Method.DeclaringType.FullName;<br>            var stopwatch = (Stopwatch)args.MethodExecutionTag;<br>            stopwatch.Stop();<br>            Log.Information(\"Exiting {ClassName}.{MethodName}. Execution time: {ElapsedMilliseconds} ms\", <br>                className, methodName, stopwatch.ElapsedMilliseconds);<br>    }<br><br>    public override void OnException(MethodExecutionArgs args)<br>    {<br>            var methodName = args.Method.Name;<br>            var className = args.Method.DeclaringType.FullName;<br>            Log.Error(args.Exception, <br>                \"Exception occurred in {ClassName}.{MethodName}: {Message}\", <br>                className, methodName, args.Exception.Message);<br>    }<br>}</pre>\n<p><strong>Usage Example:</strong></p>\n<pre>public class ReportService<br>{<br>    [LogAspect]<br>    public void GenerateReport(string reportName)<br>    {<br>        Console.WriteLine($\"Generating report: {reportName}\");<br>        // throw new InvalidOperationException(\"Report generation failed.\");<br>    }<br>}</pre>\n<h3>\ud83e\udde9 How to Set Up MethodBoundaryAspect.Fody in Your\u00a0.NET\u00a0Project</h3>\n<h3>1\ufe0f\u20e3 Install Required\u00a0Package:</h3>\n<pre>dotnet add package MethodBoundaryAspect.Fody</pre>\n<h3>2\ufe0f\u20e3 Configure the FodyWeavers.xml:</h3>\n<p>Create a FodyWeavers.xml file at the root of your\u00a0project:</p>\n<pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;<br>&lt;Weavers&gt;<br>  &lt;MethodBoundaryAspect /&gt;<br>&lt;/Weavers&gt;</pre>\n<h3>\ud83c\udf31 Benefits of Using AOP with MethodBoundaryAspect.Fody</h3>\n<p>\u2705 <strong>Centralized control</strong> over logging, transaction handling, and performance monitoring<br> \u2705 <strong>No duplicated boilerplate</strong> across your business logic<br> \u2705 <strong>Cleaner, readable, maintainable codebase</strong><br> \u2705 <strong>Easily extendable</strong> for additional concerns like validation, caching, or authorization</p>\n<h3>\ud83c\udfaf Final\u00a0Thoughts</h3>\n<p>Aspect-Oriented Programming, when used appropriately, can greatly improve the maintainability and quality of your\u00a0.NET applications. By leveraging <strong>MethodBoundaryAspect.Fody</strong>, you can focus on your business logic while systematically handling repetitive tasks like logging and transaction management in a clean, modular\u00a0way.</p>\n<blockquote>Have you tried AOP in your\u00a0.NET projects? What use cases have you found most valuable? Share your experiences in the comments\u00a0below!</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c09d36806d4d\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Aspect-Oriented Programming (AOP) in\u00a0.NET with MethodBoundaryAspect.Fody</h3>\n<p><strong>Simplifying Logging, Transaction Handling, Performance Monitoring, and\u00a0More</strong></p>\n<h3>\ud83d\ude80 Why Should You Care About\u00a0AOP?</h3>\n<p>In modern software development, we often face challenges where certain logic cuts across multiple parts of the application\u200a\u2014\u200athings\u00a0like:</p>\n<ul>\n<li>Logging</li>\n<li>Exception handling</li>\n<li>Caching</li>\n<li>Transaction management</li>\n<li>Performance monitoring</li>\n<li>Authorization and security\u00a0checks</li>\n</ul>\n<p>These are known as <strong>cross-cutting concerns</strong>. In traditional Object-Oriented Programming (OOP), addressing these concerns can lead\u00a0to:</p>\n<ul>\n<li>Scattered and duplicated code</li>\n<li>Violation of the Single Responsibility Principle (SRP)</li>\n<li>Difficulties in maintenance, testing, and\u00a0scaling</li>\n</ul>\n<p><strong>Aspect-Oriented Programming (AOP)</strong> provides a clean, elegant solution. It helps you separate these concerns from your core business logic by injecting them automatically at compile time or runtime\u200a\u2014\u200akeeping your methods clean and focused on their main responsibilities.</p>\n<h3>\ud83d\udca1 What is MethodBoundaryAspect.Fody?</h3>\n<p><strong>MethodBoundaryAspect.Fody</strong> is a Fody weaver that allows you to inject custom logic\u00a0at:</p>\n<ul>\n<li>Method <strong>entry</strong>\n</li>\n<li>Method <strong>exit</strong>\n</li>\n<li>On <strong>exceptions</strong>\n</li>\n</ul>\n<p>This is done simply by decorating your methods or classes with attributes\u200a\u2014\u200ano need to manually sprinkle repetitive code everywhere.</p>\n<h3>\ud83d\udee0\ufe0f Key Features:</h3>\n<ul>\n<li>Hook into method lifecycle: entry, exit, and exception</li>\n<li>Access rich method metadata (method info, arguments, instance, exception details)</li>\n<li>Share context between entry and exit via MethodExecutionArgs.MethodExecutionTag</li>\n<li>Apply globally, per class, or per\u00a0method</li>\n<li>Filter target methods using Regex (NamespaceFilter, TypeNameFilter, MethodNameFilter)</li>\n<li>Modify input arguments and override return\u00a0values</li>\n</ul>\n<h3>\u26a1 Example Use Cases and Implementations</h3>\n<h3>\ud83c\udfe6 Transaction Handling\u00a0Aspect</h3>\n<p>Ensure that every method wrapped in a transaction handles completion and rollback properly.</p>\n<p><strong>Implementation:</strong></p>\n<pre>public sealed class TransactionScopeAttribute : OnMethodBoundaryAspect<br>{<br>    public override void OnEntry(MethodExecutionArgs args)<br>    {<br>        args.MethodExecutionTag = new TransactionScope();<br>    } <br><br>    public override void OnExit(MethodExecutionArgs args)<br>    {<br>        var transactionScope = (TransactionScope)args.MethodExecutionTag;<br>        transactionScope.Complete();<br>        transactionScope.Dispose();<br>    }<br><br>    public override void OnException(MethodExecutionArgs args)<br>    {<br>        var transactionScope = (TransactionScope)args.MethodExecutionTag;<br>        transactionScope.Dispose();<br>    }<br>}</pre>\n<p><strong>Usage Example:</strong></p>\n<pre>public class UserService<br>{<br>    [TransactionScope]<br>    public void CreateUser()<br>    {<br>        Console.WriteLine(\"Creating user...\");<br>        // Database logic here<br>    }<br>}</pre>\n<h3>\ud83d\udcdd Logging Aspect with\u00a0Serilog</h3>\n<p>Log method entry, exit, execution time, and handle exceptions gracefully.</p>\n<p><strong>Implementation:</strong></p>\n<pre>public sealed class LogAspect : OnMethodBoundaryAspect<br>{<br>    public override void OnEntry(MethodExecutionArgs args)<br>    {<br>        var methodName = args.Method.Name;<br>        var className = args.Method.DeclaringType.FullName;<br>        args.MethodExecutionTag = Stopwatch.StartNew();<br>        Log.Information(\"Entering {ClassName}.{MethodName} with arguments: {@Arguments}\", <br>            className, methodName, args.Arguments);<br>    }<br><br>    public override void OnExit(MethodExecutionArgs args)<br>    {<br>            var methodName = args.Method.Name;<br>            var className = args.Method.DeclaringType.FullName;<br>            var stopwatch = (Stopwatch)args.MethodExecutionTag;<br>            stopwatch.Stop();<br>            Log.Information(\"Exiting {ClassName}.{MethodName}. Execution time: {ElapsedMilliseconds} ms\", <br>                className, methodName, stopwatch.ElapsedMilliseconds);<br>    }<br><br>    public override void OnException(MethodExecutionArgs args)<br>    {<br>            var methodName = args.Method.Name;<br>            var className = args.Method.DeclaringType.FullName;<br>            Log.Error(args.Exception, <br>                \"Exception occurred in {ClassName}.{MethodName}: {Message}\", <br>                className, methodName, args.Exception.Message);<br>    }<br>}</pre>\n<p><strong>Usage Example:</strong></p>\n<pre>public class ReportService<br>{<br>    [LogAspect]<br>    public void GenerateReport(string reportName)<br>    {<br>        Console.WriteLine($\"Generating report: {reportName}\");<br>        // throw new InvalidOperationException(\"Report generation failed.\");<br>    }<br>}</pre>\n<h3>\ud83e\udde9 How to Set Up MethodBoundaryAspect.Fody in Your\u00a0.NET\u00a0Project</h3>\n<h3>1\ufe0f\u20e3 Install Required\u00a0Package:</h3>\n<pre>dotnet add package MethodBoundaryAspect.Fody</pre>\n<h3>2\ufe0f\u20e3 Configure the FodyWeavers.xml:</h3>\n<p>Create a FodyWeavers.xml file at the root of your\u00a0project:</p>\n<pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;<br>&lt;Weavers&gt;<br>  &lt;MethodBoundaryAspect /&gt;<br>&lt;/Weavers&gt;</pre>\n<h3>\ud83c\udf31 Benefits of Using AOP with MethodBoundaryAspect.Fody</h3>\n<p>\u2705 <strong>Centralized control</strong> over logging, transaction handling, and performance monitoring<br> \u2705 <strong>No duplicated boilerplate</strong> across your business logic<br> \u2705 <strong>Cleaner, readable, maintainable codebase</strong><br> \u2705 <strong>Easily extendable</strong> for additional concerns like validation, caching, or authorization</p>\n<h3>\ud83c\udfaf Final\u00a0Thoughts</h3>\n<p>Aspect-Oriented Programming, when used appropriately, can greatly improve the maintainability and quality of your\u00a0.NET applications. By leveraging <strong>MethodBoundaryAspect.Fody</strong>, you can focus on your business logic while systematically handling repetitive tasks like logging and transaction management in a clean, modular\u00a0way.</p>\n<blockquote>Have you tried AOP in your\u00a0.NET projects? What use cases have you found most valuable? Share your experiences in the comments\u00a0below!</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c09d36806d4d\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["aspect-oriented","revitapi","autodesk-revit-addins"]},{"title":"Storing Custom Data in Revit Using Extensible Storage\u200a\u2014\u200aA Practical Guide","pubDate":"2025-04-19 20:17:30","link":"https://medium.com/@khalidfathyuar/storing-custom-data-in-revit-using-extensible-storage-a-practical-guide-07dcc3c2128c?source=rss-10666600d0ce------2","guid":"https://medium.com/p/07dcc3c2128c","author":"Khalid Fathy","thumbnail":"","description":"\n<h3>Storing Custom Data in Revit Using Extensible Storage\u200a\u2014\u200aA Practical Guide</h3>\n<p>When developing Revit plugins, you\u2019ll eventually need to store custom data that Revit\u2019s built-in parameters just don\u2019t support. Maybe it\u2019s spatial metadata, plugin-specific configuration, simulation results, or a timestamped action\u00a0history.</p>\n<p>Instead of relying on external databases or parameter hacks, Revit provides a native and powerful feature called <strong>Extensible Storage</strong>.</p>\n<p>It allows you to define structured, typed data (like classes), attach it to Revit elements, and retrieve it later\u200a\u2014\u200aall embedded inside the\u00a0.rvt\u00a0model.</p>\n<p>This article walks you\u00a0through:</p>\n<ul>\n<li>What Extensible Storage\u00a0is</li>\n<li>Supported field\u00a0types</li>\n<li>How to create and attach schema\u00a0data</li>\n<li>Reading that data\u00a0back</li>\n<li>Setting proper access permissions</li>\n<li>And a complete working example with best practices</li>\n</ul>\n<h3>What Is Extensible Storage?</h3>\n<p>Extensible Storage enables Revit developers to define class-like structures called <strong>schemas</strong> and attach instances of those structures, called <strong>entities</strong>, to Revit elements. Each schema defines one or more <strong>fields</strong> (similar to class properties), and entities store actual values for those\u00a0fields.</p>\n<p>You can:</p>\n<ul>\n<li>Define custom fields like XYZ, double, string,\u00a0etc.</li>\n<li>Save that data to any element in the\u00a0model</li>\n<li>Read it back later\u200a\u2014\u200aeven after reopening the\u00a0file</li>\n<li>Set access rules to control who can read or write\u00a0it</li>\n</ul>\n<p>Think of it as your plugin\u2019s personal, structured memory\u200a\u2014\u200abuilt directly into the Revit\u00a0file.</p>\n<h3>Supported Types and Their Default\u00a0Values</h3>\n<p>Extensible Storage only supports a limited set of types. Each field in your schema must be one of the following:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KDuhKSOTBeEXyATygthoGw.png\"></figure><h3>Types of Fields in Extensible Storage</h3>\n<p>In Revit\u2019s Extensible Storage API, a <strong>field</strong> is like a class property\u200a\u2014\u200ait defines what kind of data can be stored in a schema. Fields are created using SchemaBuilder and configured via a FieldBuilder.</p>\n<p>Revit supports several types of fields to suit different data structures.</p>\n<h3>Entity Fields (Nested Schemas / SubEntities)</h3>\n<p>You can create a field whose type is Autodesk.Revit.DB.ExtensibleStorage.Entity.</p>\n<p>This means a field can hold another <strong>entire schema</strong>\u200a\u2014\u200alike a class within a class. These are known as <strong>SubSchemas</strong> or <strong>SubEntities</strong>, and are useful when your data model needs to be modular or hierarchical.</p>\n<ul><li>Default value: An entity with null schema and Guid.Empty</li></ul>\n<pre>FieldBuilder field = schemaBuilder.AddSimpleField(\"SubEntityField\", typeof(Entity));<br>field.SetSubSchemaGUID(subSchemaGuid);</pre>\n<p>Use SetSubSchemaGUID() to define the expected schema inside the\u00a0field.</p>\n<h3>String Field Limitations</h3>\n<p>Revit enforces a <strong>16 MB limit</strong> on individual string values in extensible storage.</p>\n<p>So while you can use string as a field type, you must avoid storing overly large serialized blobs (like large JSON documents) inside a string\u00a0field.</p>\n<h3>Field Creation\u00a0Methods</h3>\n<p>The API provides three methods for adding fields depending on your data structure:</p>\n<h4>\u27a4 AddSimpleField(string name, Type\u00a0type)</h4>\n<p>Adds a field for a single\u00a0value.</p>\n<ul>\n<li>Allowed types: int, double, XYZ, string, bool, Guid, Entity,\u00a0etc.</li>\n<li>Returns a FieldBuilder to let you configure units, documentation, or sub-schemas.</li>\n</ul>\n<pre>FieldBuilder field = schemaBuilder.AddSimpleField(\"Length\", typeof(double));</pre>\n<h4>\u27a4 AddArrayField(string name, Type\u00a0type)</h4>\n<p>Adds a field that stores an array or list of\u00a0values.</p>\n<ul><li>Same supported types as AddSimpleField</li></ul>\n<pre>FieldBuilder arrayField = schemaBuilder.AddArrayField(\"Points\", typeof(XYZ));</pre>\n<h4>\u27a4 AddMapField(string name, Type keyType, Type valueType)</h4>\n<p>Adds a dictionary-like field that stores key-value pairs.</p>\n<ul>\n<li>Keys must be one of: int, short, byte, string, bool, ElementId, Guid</li>\n<li>Values can be any valid simple field\u00a0type</li>\n</ul>\n<pre>FieldBuilder mapField = schemaBuilder.AddMapField(\"LengthsById\", typeof(Guid), typeof(double));</pre>\n<h3>FieldBuilder and Schema Finalization</h3>\n<p>After you add a field using AddSimpleField, AddArrayField, or AddMapField, you get a FieldBuilder. Use it to configure the\u00a0field:</p>\n<ul>\n<li>SetSpec() or SetUnitType() \u2192 for numeric and vector\u00a0fields</li>\n<li>SetDocumentation() \u2192 add a description to your\u00a0field</li>\n<li>SetSubSchemaGUID() \u2192 for Entity fields (nested\u00a0schemas)</li>\n</ul>\n<pre>FieldBuilder fb = schemaBuilder.AddSimpleField(\"WireLength\", typeof(double));<br>fb.SetDocumentation(\"Length of wire in meters.\");</pre>\n<blockquote>\n<em>Once you call </em><em>schemaBuilder.Finish(), the schema is finalized and cannot be modified. After that, use </em><em>Schema.GetField(\"FieldName\") to access the\u00a0fields.</em>\n</blockquote>\n<h3>Creating and Writing Extensible Storage\u00a0Data</h3>\n<p>To write data using Extensible Storage in Revit, you follow these main\u00a0steps:</p>\n<ol>\n<li>Create a unique <strong>SchemaBuilder</strong>\n</li>\n<li>Add fields with types, documentation, and\u00a0units</li>\n<li>Set the <strong>read/write access\u00a0levels</strong>\n</li>\n<li>Finalize the\u00a0schema</li>\n<li>Create an <strong>Entity</strong> and assign field\u00a0values</li>\n<li>Attach it to a selected element in a <strong>Transaction</strong>\n</li>\n</ol>\n<p>Below is a complete implementation of a Revit external command that writes extensible storage data to an element chosen by the user. It demonstrates conditional unit support, field documentation, and access\u00a0control.</p>\n<pre>using Autodesk.Revit.Attributes;<br>using Autodesk.Revit.DB.ExtensibleStorage;<br>using Autodesk.Revit.UI;<br>using Autodesk.Revit.UI.Selection;<br>using Nice3point.Revit.Toolkit.External;<br>using OperationCanceledException = Autodesk.Revit.Exceptions.OperationCanceledException;<br><br>namespace ExtensibleStorage.Commands;<br><br>/// &lt;summary&gt;<br>///     Writes extensible storage data to a user-selected element in a Revit document.<br>///     The data includes spatial and descriptive metadata such as location, length, a note, and a timestamp.<br>/// &lt;/summary&gt;<br>[UsedImplicitly]<br>[Transaction(TransactionMode.Manual)]<br>internal class WriteExtensibleStorage : ExternalCommand<br>{<br>    public override void Execute()<br>    {<br>        // Step 1: Create schema with unique GUID<br>        var schemaBuilder = new SchemaBuilder(Guid.NewGuid());<br><br>        // Step 2: Configure schema metadata<br>        schemaBuilder.SetVendorId(\"Khalid\"); // MUST match &lt;VendorId&gt; in your .addin file<br>        schemaBuilder.SetSchemaName(\"MySchema\");<br>        schemaBuilder.SetReadAccessLevel(AccessLevel.Public);<br>        schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor);<br><br>        // Step 3: Define fields with documentation and unit handling<br>        var locationFieldBuilder = schemaBuilder.AddSimpleField(\"Location\", typeof(XYZ));<br>#if R21_OR_GREATER<br>        locationFieldBuilder.SetSpec(SpecTypeId.Length);<br>#else<br>        locationFieldBuilder.SetUnitType(UnitType.UT_Length);<br>#endif<br>        locationFieldBuilder.SetDocumentation(\"3D point representing the splice location.\");<br><br>        var lengthFieldBuilder = schemaBuilder.AddSimpleField(\"WireLength\", typeof(double));<br>#if R21_OR_GREATER<br>        lengthFieldBuilder.SetSpec(SpecTypeId.Length);<br>#else<br>        lengthFieldBuilder.SetUnitType(UnitType.UT_Length);<br>#endif<br>        lengthFieldBuilder.SetDocumentation(\"Total wire length from the splice to the endpoint.\");<br><br>        var descriptionFieldBuilder = schemaBuilder.AddSimpleField(\"Description\", typeof(string));<br>        descriptionFieldBuilder.SetDocumentation(\"Human-readable description of the wire splice.\");<br><br>        var timeFieldBuilder = schemaBuilder.AddSimpleField(\"SpliceTime\", typeof(string));<br>        timeFieldBuilder.SetDocumentation(\"The date and time of the splice in ISO-8601 format.\");<br><br>        // Step 4: Finalize the schema<br>        var schema = schemaBuilder.Finish();<br><br>        // Step 5: Create entity and populate values<br>        var entity = new Entity(schema);<br>#if R21_OR_GREATER<br>        entity.Set(schema.GetField(\"Location\"), new XYZ(1, 2, 3), UnitTypeId.Meters);<br>        entity.Set(schema.GetField(\"WireLength\"), 12.5, UnitTypeId.Meters);<br>#else<br>        entity.Set(schema.GetField(\"Location\"), new XYZ(1, 2, 3), DisplayUnitType.DUT_METERS);<br>        entity.Set(schema.GetField(\"WireLength\"), 12.5, DisplayUnitType.DUT_METERS);<br>#endif<br>        entity.Set(schema.GetField(\"Description\"), \"Main splice near junction box\");<br>        entity.Set(schema.GetField(\"SpliceTime\"), DateTime.Now.ToString(\"o\")); // ISO format<br><br>        // Step 6: Prompt for target element and apply entity<br>        try<br>        {<br>            var reference = UiDocument.Selection.PickObject(ObjectType.Element, \"Please select an element\");<br>            var element = Document.GetElement(reference);<br><br>            using var transaction = new Transaction(Document);<br>            transaction.Start(\"Write Extensible Storage\");<br>            element.SetEntity(entity);<br>            transaction.Commit();<br>        }<br>        catch (OperationCanceledException)<br>        {<br>            TaskDialog.Show(\"Canceled\", \"Operation was canceled by user.\");<br>        }<br>        catch (Exception e)<br>        {<br>            TaskDialog.Show(\"Error\", e.Message);<br>            throw;<br>        }<br>    }<br>}</pre>\n<h3>Reading Extensible Storage Data from a Revit\u00a0Element</h3>\n<p>Once you\u2019ve attached Extensible Storage data to an element, you can retrieve it anytime using the same schema. Reading the data involves:</p>\n<ol>\n<li>Identifying the correct schema (by SchemaName and VendorId)</li>\n<li>Calling element.GetEntity(schema) to retrieve the\u00a0entity</li>\n<li>Accessing individual field values using entity.Get&lt;T&gt;()</li>\n<li>Handling any missing or invalid data gracefully</li>\n</ol>\n<p>Below is a complete external command that prompts the user to select an element, fetches its Extensible Storage entity, and displays the stored information in a simple Revit TaskDialog.</p>\n<pre>using Autodesk.Revit.Attributes;<br>using Autodesk.Revit.DB.ExtensibleStorage;<br>using Autodesk.Revit.UI;<br>using Autodesk.Revit.UI.Selection;<br>using Nice3point.Revit.Toolkit.External;<br>using OperationCanceledException = Autodesk.Revit.Exceptions.OperationCanceledException;<br><br>namespace ExtensibleStorage.Commands;<br><br><br>/// &lt;summary&gt;<br>///     Command to read extensible storage data from a user-selected Revit element.<br>///     Displays stored schema data using a TaskDialog.<br>/// &lt;/summary&gt;<br>[UsedImplicitly]<br>[Transaction(TransactionMode.Manual)]<br>internal class ReadExtensibleStorage : ExternalCommand<br>{<br>    /// &lt;summary&gt;<br>    ///     Entry point for the external command.<br>    ///     Prompts the user to select an element, then reads and displays extensible storage data.<br>    /// &lt;/summary&gt;<br>    public override void Execute()<br>    {<br>        try<br>        {<br>            // Prompt user to select an element in the active document<br>            var reference = UiDocument.Selection.PickObject(ObjectType.Element, \"Please select an element\");<br>            var element = Document.GetElement(reference);<br><br>            // Retrieve the schema by name and vendor ID<br>            var schema = Schema.ListSchemas()<br>                .FirstOrDefault(s =&gt; s.SchemaName == \"MySchema\" &amp;&amp; s.VendorId == \"KHALID\"); // Replace with your actual VendorId<br><br>            if (schema == null)<br>            {<br>                TaskDialog.Show(\"Schema Not Found\", \"The schema 'MySchema' was not found.\");<br>                return;<br>            }<br><br>            // Validate selected element<br>            if (!element.IsValidObject)<br>            {<br>                TaskDialog.Show(\"Invalid Element\", \"The selected element cannot store external data.\");<br>                return;<br>            }<br><br>            // Try to get the associated entity from the element<br>            var entity = element.GetEntity(schema);<br><br>            if (!entity.IsValid())<br>            {<br>                TaskDialog.Show(\"No Data\", \"This element does not contain extensible storage data.\");<br>                return;<br>            }<br><br>            // Retrieve and format the stored values<br>#if R21_OR_GREATER<br>            var location = entity.Get&lt;XYZ&gt;(schema.GetField(\"Location\"), UnitTypeId.Meters);<br>            var length = entity.Get&lt;double&gt;(schema.GetField(\"WireLength\"), UnitTypeId.Meters);<br>#else<br>var location = entity.Get&lt;XYZ&gt;(schema.GetField(\"Location\"), DisplayUnitType.DUT_METERS);<br>var length = entity.Get&lt;double&gt;(schema.GetField(\"WireLength\"), DisplayUnitType.DUT_METERS);<br>#endif<br><br>            var description = entity.Get&lt;string&gt;(schema.GetField(\"Description\"));<br>            var timeString = entity.Get&lt;string&gt;(schema.GetField(\"SpliceTime\"));<br><br>            // Build a message to show in the TaskDialog<br>            var msg = $\"\ud83d\udccc Extensible Storage Data:\\n\\n\" +<br>                      $\"- Location: ({location.X:F2}, {location.Y:F2}, {location.Z:F2})\\n\" +<br>                      $\"- Wire Length: {length:F2} m\\n\" +<br>                      $\"- Description: {description}\\n\" +<br>                      $\"- Splice Time: {timeString}\";<br><br>            // Show the data in a Revit dialog<br>            TaskDialog.Show(\"Wire Splice Info\", msg);<br>        }<br>        catch (OperationCanceledException)<br>        {<br>            // User canceled the selection<br>            TaskDialog.Show(\"Canceled\", \"Operation canceled by user.\");<br>        }<br>        catch (Exception ex)<br>        {<br>            // Unexpected error occurred<br>            TaskDialog.Show(\"Error\", ex.Message);<br>            throw;<br>        }<br>    }<br>}</pre>\n<h3>Access Levels: Controlling Read and Write Permissions</h3>\n<p>When creating a schema, you can define <strong>who can read or write it</strong> by setting its AccessLevel:</p>\n<h3>Public</h3>\n<pre>schemaBuilder.SetReadAccessLevel(AccessLevel.Public);<br>schemaBuilder.SetWriteAccessLevel(AccessLevel.Public);</pre>\n<blockquote><em>Anyone can read and write the data. Useful for shared or open data structures.</em></blockquote>\n<h3>Vendor</h3>\n<pre>schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor);<br>schemaBuilder.SetVendorId(\"YourCompanyName\"); // must match .addin file</pre>\n<blockquote>\n<em>Only your vendor can write (read can be </em><em>Public, </em><em>Vendor, or </em><em>Application).</em>\n</blockquote>\n<p><strong>Important</strong>: When using AccessLevel.Vendor, you must match the VendorId in your\u00a0.addin\u00a0file:</p>\n<pre>&lt;VendorId&gt;YourCompanyName&lt;/VendorId&gt;</pre>\n<h3>Application</h3>\n<pre>schemaBuilder.SetWriteAccessLevel(AccessLevel.Application);<br>schemaBuilder.SetApplicationId(new Guid(\"your-plugin-guid\"));</pre>\n<blockquote><em>Only your specific add-in can access the schema. Most restrictive.</em></blockquote>\n<h3>Are There Already Schemas in Your\u00a0File?</h3>\n<p>Yes! Revit and third-party plugins often use Extensible Storage.</p>\n<p>You can inspect them\u00a0using:</p>\n<pre>var allSchemas = Schema.ListSchemas();</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wA0dnfIMfGZXbSO0QqUS1g.png\"><figcaption>showing all registered schemas in the current Revit document, including schema names, GUIDs, access levels, vendor IDs, application IDs, and documentation. These entries include both built-in Revit data and third-party plugin metadata like MySchema, PipeData, and FamilyBrowserStatus.</figcaption></figure><p>You can find the complete source code\u200a\u2014\u200aincluding both the <strong>write</strong> and <strong>read</strong> commands, with conditional compilation support for <strong>Revit 2020 through Revit 2026</strong>\u200a\u2014\u200aon my\u00a0GitHub:</p>\n<p>\ud83d\udd17 <a href=\"https://github.com/khalidfathyFL/ExtensibleStorage\">View the Extensible Storage Demo on\u00a0GitHub</a></p>\n<p>Feel free to explore, fork, or contribute. I hope this guide helps you confidently integrate structured metadata into your Revit workflows!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=07dcc3c2128c\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Storing Custom Data in Revit Using Extensible Storage\u200a\u2014\u200aA Practical Guide</h3>\n<p>When developing Revit plugins, you\u2019ll eventually need to store custom data that Revit\u2019s built-in parameters just don\u2019t support. Maybe it\u2019s spatial metadata, plugin-specific configuration, simulation results, or a timestamped action\u00a0history.</p>\n<p>Instead of relying on external databases or parameter hacks, Revit provides a native and powerful feature called <strong>Extensible Storage</strong>.</p>\n<p>It allows you to define structured, typed data (like classes), attach it to Revit elements, and retrieve it later\u200a\u2014\u200aall embedded inside the\u00a0.rvt\u00a0model.</p>\n<p>This article walks you\u00a0through:</p>\n<ul>\n<li>What Extensible Storage\u00a0is</li>\n<li>Supported field\u00a0types</li>\n<li>How to create and attach schema\u00a0data</li>\n<li>Reading that data\u00a0back</li>\n<li>Setting proper access permissions</li>\n<li>And a complete working example with best practices</li>\n</ul>\n<h3>What Is Extensible Storage?</h3>\n<p>Extensible Storage enables Revit developers to define class-like structures called <strong>schemas</strong> and attach instances of those structures, called <strong>entities</strong>, to Revit elements. Each schema defines one or more <strong>fields</strong> (similar to class properties), and entities store actual values for those\u00a0fields.</p>\n<p>You can:</p>\n<ul>\n<li>Define custom fields like XYZ, double, string,\u00a0etc.</li>\n<li>Save that data to any element in the\u00a0model</li>\n<li>Read it back later\u200a\u2014\u200aeven after reopening the\u00a0file</li>\n<li>Set access rules to control who can read or write\u00a0it</li>\n</ul>\n<p>Think of it as your plugin\u2019s personal, structured memory\u200a\u2014\u200abuilt directly into the Revit\u00a0file.</p>\n<h3>Supported Types and Their Default\u00a0Values</h3>\n<p>Extensible Storage only supports a limited set of types. Each field in your schema must be one of the following:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KDuhKSOTBeEXyATygthoGw.png\"></figure><h3>Types of Fields in Extensible Storage</h3>\n<p>In Revit\u2019s Extensible Storage API, a <strong>field</strong> is like a class property\u200a\u2014\u200ait defines what kind of data can be stored in a schema. Fields are created using SchemaBuilder and configured via a FieldBuilder.</p>\n<p>Revit supports several types of fields to suit different data structures.</p>\n<h3>Entity Fields (Nested Schemas / SubEntities)</h3>\n<p>You can create a field whose type is Autodesk.Revit.DB.ExtensibleStorage.Entity.</p>\n<p>This means a field can hold another <strong>entire schema</strong>\u200a\u2014\u200alike a class within a class. These are known as <strong>SubSchemas</strong> or <strong>SubEntities</strong>, and are useful when your data model needs to be modular or hierarchical.</p>\n<ul><li>Default value: An entity with null schema and Guid.Empty</li></ul>\n<pre>FieldBuilder field = schemaBuilder.AddSimpleField(\"SubEntityField\", typeof(Entity));<br>field.SetSubSchemaGUID(subSchemaGuid);</pre>\n<p>Use SetSubSchemaGUID() to define the expected schema inside the\u00a0field.</p>\n<h3>String Field Limitations</h3>\n<p>Revit enforces a <strong>16 MB limit</strong> on individual string values in extensible storage.</p>\n<p>So while you can use string as a field type, you must avoid storing overly large serialized blobs (like large JSON documents) inside a string\u00a0field.</p>\n<h3>Field Creation\u00a0Methods</h3>\n<p>The API provides three methods for adding fields depending on your data structure:</p>\n<h4>\u27a4 AddSimpleField(string name, Type\u00a0type)</h4>\n<p>Adds a field for a single\u00a0value.</p>\n<ul>\n<li>Allowed types: int, double, XYZ, string, bool, Guid, Entity,\u00a0etc.</li>\n<li>Returns a FieldBuilder to let you configure units, documentation, or sub-schemas.</li>\n</ul>\n<pre>FieldBuilder field = schemaBuilder.AddSimpleField(\"Length\", typeof(double));</pre>\n<h4>\u27a4 AddArrayField(string name, Type\u00a0type)</h4>\n<p>Adds a field that stores an array or list of\u00a0values.</p>\n<ul><li>Same supported types as AddSimpleField</li></ul>\n<pre>FieldBuilder arrayField = schemaBuilder.AddArrayField(\"Points\", typeof(XYZ));</pre>\n<h4>\u27a4 AddMapField(string name, Type keyType, Type valueType)</h4>\n<p>Adds a dictionary-like field that stores key-value pairs.</p>\n<ul>\n<li>Keys must be one of: int, short, byte, string, bool, ElementId, Guid</li>\n<li>Values can be any valid simple field\u00a0type</li>\n</ul>\n<pre>FieldBuilder mapField = schemaBuilder.AddMapField(\"LengthsById\", typeof(Guid), typeof(double));</pre>\n<h3>FieldBuilder and Schema Finalization</h3>\n<p>After you add a field using AddSimpleField, AddArrayField, or AddMapField, you get a FieldBuilder. Use it to configure the\u00a0field:</p>\n<ul>\n<li>SetSpec() or SetUnitType() \u2192 for numeric and vector\u00a0fields</li>\n<li>SetDocumentation() \u2192 add a description to your\u00a0field</li>\n<li>SetSubSchemaGUID() \u2192 for Entity fields (nested\u00a0schemas)</li>\n</ul>\n<pre>FieldBuilder fb = schemaBuilder.AddSimpleField(\"WireLength\", typeof(double));<br>fb.SetDocumentation(\"Length of wire in meters.\");</pre>\n<blockquote>\n<em>Once you call </em><em>schemaBuilder.Finish(), the schema is finalized and cannot be modified. After that, use </em><em>Schema.GetField(\"FieldName\") to access the\u00a0fields.</em>\n</blockquote>\n<h3>Creating and Writing Extensible Storage\u00a0Data</h3>\n<p>To write data using Extensible Storage in Revit, you follow these main\u00a0steps:</p>\n<ol>\n<li>Create a unique <strong>SchemaBuilder</strong>\n</li>\n<li>Add fields with types, documentation, and\u00a0units</li>\n<li>Set the <strong>read/write access\u00a0levels</strong>\n</li>\n<li>Finalize the\u00a0schema</li>\n<li>Create an <strong>Entity</strong> and assign field\u00a0values</li>\n<li>Attach it to a selected element in a <strong>Transaction</strong>\n</li>\n</ol>\n<p>Below is a complete implementation of a Revit external command that writes extensible storage data to an element chosen by the user. It demonstrates conditional unit support, field documentation, and access\u00a0control.</p>\n<pre>using Autodesk.Revit.Attributes;<br>using Autodesk.Revit.DB.ExtensibleStorage;<br>using Autodesk.Revit.UI;<br>using Autodesk.Revit.UI.Selection;<br>using Nice3point.Revit.Toolkit.External;<br>using OperationCanceledException = Autodesk.Revit.Exceptions.OperationCanceledException;<br><br>namespace ExtensibleStorage.Commands;<br><br>/// &lt;summary&gt;<br>///     Writes extensible storage data to a user-selected element in a Revit document.<br>///     The data includes spatial and descriptive metadata such as location, length, a note, and a timestamp.<br>/// &lt;/summary&gt;<br>[UsedImplicitly]<br>[Transaction(TransactionMode.Manual)]<br>internal class WriteExtensibleStorage : ExternalCommand<br>{<br>    public override void Execute()<br>    {<br>        // Step 1: Create schema with unique GUID<br>        var schemaBuilder = new SchemaBuilder(Guid.NewGuid());<br><br>        // Step 2: Configure schema metadata<br>        schemaBuilder.SetVendorId(\"Khalid\"); // MUST match &lt;VendorId&gt; in your .addin file<br>        schemaBuilder.SetSchemaName(\"MySchema\");<br>        schemaBuilder.SetReadAccessLevel(AccessLevel.Public);<br>        schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor);<br><br>        // Step 3: Define fields with documentation and unit handling<br>        var locationFieldBuilder = schemaBuilder.AddSimpleField(\"Location\", typeof(XYZ));<br>#if R21_OR_GREATER<br>        locationFieldBuilder.SetSpec(SpecTypeId.Length);<br>#else<br>        locationFieldBuilder.SetUnitType(UnitType.UT_Length);<br>#endif<br>        locationFieldBuilder.SetDocumentation(\"3D point representing the splice location.\");<br><br>        var lengthFieldBuilder = schemaBuilder.AddSimpleField(\"WireLength\", typeof(double));<br>#if R21_OR_GREATER<br>        lengthFieldBuilder.SetSpec(SpecTypeId.Length);<br>#else<br>        lengthFieldBuilder.SetUnitType(UnitType.UT_Length);<br>#endif<br>        lengthFieldBuilder.SetDocumentation(\"Total wire length from the splice to the endpoint.\");<br><br>        var descriptionFieldBuilder = schemaBuilder.AddSimpleField(\"Description\", typeof(string));<br>        descriptionFieldBuilder.SetDocumentation(\"Human-readable description of the wire splice.\");<br><br>        var timeFieldBuilder = schemaBuilder.AddSimpleField(\"SpliceTime\", typeof(string));<br>        timeFieldBuilder.SetDocumentation(\"The date and time of the splice in ISO-8601 format.\");<br><br>        // Step 4: Finalize the schema<br>        var schema = schemaBuilder.Finish();<br><br>        // Step 5: Create entity and populate values<br>        var entity = new Entity(schema);<br>#if R21_OR_GREATER<br>        entity.Set(schema.GetField(\"Location\"), new XYZ(1, 2, 3), UnitTypeId.Meters);<br>        entity.Set(schema.GetField(\"WireLength\"), 12.5, UnitTypeId.Meters);<br>#else<br>        entity.Set(schema.GetField(\"Location\"), new XYZ(1, 2, 3), DisplayUnitType.DUT_METERS);<br>        entity.Set(schema.GetField(\"WireLength\"), 12.5, DisplayUnitType.DUT_METERS);<br>#endif<br>        entity.Set(schema.GetField(\"Description\"), \"Main splice near junction box\");<br>        entity.Set(schema.GetField(\"SpliceTime\"), DateTime.Now.ToString(\"o\")); // ISO format<br><br>        // Step 6: Prompt for target element and apply entity<br>        try<br>        {<br>            var reference = UiDocument.Selection.PickObject(ObjectType.Element, \"Please select an element\");<br>            var element = Document.GetElement(reference);<br><br>            using var transaction = new Transaction(Document);<br>            transaction.Start(\"Write Extensible Storage\");<br>            element.SetEntity(entity);<br>            transaction.Commit();<br>        }<br>        catch (OperationCanceledException)<br>        {<br>            TaskDialog.Show(\"Canceled\", \"Operation was canceled by user.\");<br>        }<br>        catch (Exception e)<br>        {<br>            TaskDialog.Show(\"Error\", e.Message);<br>            throw;<br>        }<br>    }<br>}</pre>\n<h3>Reading Extensible Storage Data from a Revit\u00a0Element</h3>\n<p>Once you\u2019ve attached Extensible Storage data to an element, you can retrieve it anytime using the same schema. Reading the data involves:</p>\n<ol>\n<li>Identifying the correct schema (by SchemaName and VendorId)</li>\n<li>Calling element.GetEntity(schema) to retrieve the\u00a0entity</li>\n<li>Accessing individual field values using entity.Get&lt;T&gt;()</li>\n<li>Handling any missing or invalid data gracefully</li>\n</ol>\n<p>Below is a complete external command that prompts the user to select an element, fetches its Extensible Storage entity, and displays the stored information in a simple Revit TaskDialog.</p>\n<pre>using Autodesk.Revit.Attributes;<br>using Autodesk.Revit.DB.ExtensibleStorage;<br>using Autodesk.Revit.UI;<br>using Autodesk.Revit.UI.Selection;<br>using Nice3point.Revit.Toolkit.External;<br>using OperationCanceledException = Autodesk.Revit.Exceptions.OperationCanceledException;<br><br>namespace ExtensibleStorage.Commands;<br><br><br>/// &lt;summary&gt;<br>///     Command to read extensible storage data from a user-selected Revit element.<br>///     Displays stored schema data using a TaskDialog.<br>/// &lt;/summary&gt;<br>[UsedImplicitly]<br>[Transaction(TransactionMode.Manual)]<br>internal class ReadExtensibleStorage : ExternalCommand<br>{<br>    /// &lt;summary&gt;<br>    ///     Entry point for the external command.<br>    ///     Prompts the user to select an element, then reads and displays extensible storage data.<br>    /// &lt;/summary&gt;<br>    public override void Execute()<br>    {<br>        try<br>        {<br>            // Prompt user to select an element in the active document<br>            var reference = UiDocument.Selection.PickObject(ObjectType.Element, \"Please select an element\");<br>            var element = Document.GetElement(reference);<br><br>            // Retrieve the schema by name and vendor ID<br>            var schema = Schema.ListSchemas()<br>                .FirstOrDefault(s =&gt; s.SchemaName == \"MySchema\" &amp;&amp; s.VendorId == \"KHALID\"); // Replace with your actual VendorId<br><br>            if (schema == null)<br>            {<br>                TaskDialog.Show(\"Schema Not Found\", \"The schema 'MySchema' was not found.\");<br>                return;<br>            }<br><br>            // Validate selected element<br>            if (!element.IsValidObject)<br>            {<br>                TaskDialog.Show(\"Invalid Element\", \"The selected element cannot store external data.\");<br>                return;<br>            }<br><br>            // Try to get the associated entity from the element<br>            var entity = element.GetEntity(schema);<br><br>            if (!entity.IsValid())<br>            {<br>                TaskDialog.Show(\"No Data\", \"This element does not contain extensible storage data.\");<br>                return;<br>            }<br><br>            // Retrieve and format the stored values<br>#if R21_OR_GREATER<br>            var location = entity.Get&lt;XYZ&gt;(schema.GetField(\"Location\"), UnitTypeId.Meters);<br>            var length = entity.Get&lt;double&gt;(schema.GetField(\"WireLength\"), UnitTypeId.Meters);<br>#else<br>var location = entity.Get&lt;XYZ&gt;(schema.GetField(\"Location\"), DisplayUnitType.DUT_METERS);<br>var length = entity.Get&lt;double&gt;(schema.GetField(\"WireLength\"), DisplayUnitType.DUT_METERS);<br>#endif<br><br>            var description = entity.Get&lt;string&gt;(schema.GetField(\"Description\"));<br>            var timeString = entity.Get&lt;string&gt;(schema.GetField(\"SpliceTime\"));<br><br>            // Build a message to show in the TaskDialog<br>            var msg = $\"\ud83d\udccc Extensible Storage Data:\\n\\n\" +<br>                      $\"- Location: ({location.X:F2}, {location.Y:F2}, {location.Z:F2})\\n\" +<br>                      $\"- Wire Length: {length:F2} m\\n\" +<br>                      $\"- Description: {description}\\n\" +<br>                      $\"- Splice Time: {timeString}\";<br><br>            // Show the data in a Revit dialog<br>            TaskDialog.Show(\"Wire Splice Info\", msg);<br>        }<br>        catch (OperationCanceledException)<br>        {<br>            // User canceled the selection<br>            TaskDialog.Show(\"Canceled\", \"Operation canceled by user.\");<br>        }<br>        catch (Exception ex)<br>        {<br>            // Unexpected error occurred<br>            TaskDialog.Show(\"Error\", ex.Message);<br>            throw;<br>        }<br>    }<br>}</pre>\n<h3>Access Levels: Controlling Read and Write Permissions</h3>\n<p>When creating a schema, you can define <strong>who can read or write it</strong> by setting its AccessLevel:</p>\n<h3>Public</h3>\n<pre>schemaBuilder.SetReadAccessLevel(AccessLevel.Public);<br>schemaBuilder.SetWriteAccessLevel(AccessLevel.Public);</pre>\n<blockquote><em>Anyone can read and write the data. Useful for shared or open data structures.</em></blockquote>\n<h3>Vendor</h3>\n<pre>schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor);<br>schemaBuilder.SetVendorId(\"YourCompanyName\"); // must match .addin file</pre>\n<blockquote>\n<em>Only your vendor can write (read can be </em><em>Public, </em><em>Vendor, or </em><em>Application).</em>\n</blockquote>\n<p><strong>Important</strong>: When using AccessLevel.Vendor, you must match the VendorId in your\u00a0.addin\u00a0file:</p>\n<pre>&lt;VendorId&gt;YourCompanyName&lt;/VendorId&gt;</pre>\n<h3>Application</h3>\n<pre>schemaBuilder.SetWriteAccessLevel(AccessLevel.Application);<br>schemaBuilder.SetApplicationId(new Guid(\"your-plugin-guid\"));</pre>\n<blockquote><em>Only your specific add-in can access the schema. Most restrictive.</em></blockquote>\n<h3>Are There Already Schemas in Your\u00a0File?</h3>\n<p>Yes! Revit and third-party plugins often use Extensible Storage.</p>\n<p>You can inspect them\u00a0using:</p>\n<pre>var allSchemas = Schema.ListSchemas();</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wA0dnfIMfGZXbSO0QqUS1g.png\"><figcaption>showing all registered schemas in the current Revit document, including schema names, GUIDs, access levels, vendor IDs, application IDs, and documentation. These entries include both built-in Revit data and third-party plugin metadata like MySchema, PipeData, and FamilyBrowserStatus.</figcaption></figure><p>You can find the complete source code\u200a\u2014\u200aincluding both the <strong>write</strong> and <strong>read</strong> commands, with conditional compilation support for <strong>Revit 2020 through Revit 2026</strong>\u200a\u2014\u200aon my\u00a0GitHub:</p>\n<p>\ud83d\udd17 <a href=\"https://github.com/khalidfathyFL/ExtensibleStorage\">View the Extensible Storage Demo on\u00a0GitHub</a></p>\n<p>Feel free to explore, fork, or contribute. I hope this guide helps you confidently integrate structured metadata into your Revit workflows!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=07dcc3c2128c\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["revit","autodesk","revitapi","development"]}]}